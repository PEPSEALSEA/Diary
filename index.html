<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Diary</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0b0e14;
            --panel: #111620;
            --panel-2: #0f1420;
            --text: #e6edf3;
            --muted: #9aa5b1;
            --accent: #3b82f6;
            --accent-2: #60a5fa;
            --danger: #ef4444;
            --ok: #10b981;
            --border: #1f2937;
            --input: #0c121c
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            min-height: 100%
        }

        body {
            margin: 0;
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            background: linear-gradient(180deg, #0b0e14, #0a0f1a 40%, #0b1220);
            color: var(--text)
        }

        .container {
            max-width: 960px;
            margin: 0 auto;
            padding: 24px
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px
        }

        .brand {
            font-weight: 700;
            letter-spacing: .4px
        }

        .nav a {
            color: var(--muted);
            text-decoration: none;
            margin-left: 16px
        }

        .card {
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
            padding: 20px
        }

        .row {
            display: flex;
            gap: 16px;
            flex-wrap: wrap
        }

        .col {
            flex: 1 1 320px
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px
        }

        input,
        textarea,
        select,
        button {
            font: inherit
        }

        input,
        textarea,
        select {
            width: 100%;
            padding: 12px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--input);
            color: var(--text)
        }

        textarea {
            min-height: 220px;
            resize: vertical
        }

        button {
            background: var(--accent);
            color: white;
            border: 0;
            border-radius: 10px;
            padding: 10px 14px;
            cursor: pointer
        }

        button.ghost {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text)
        }

        button.danger {
            background: var(--danger)
        }

        button:disabled {
            opacity: .6;
            cursor: not-allowed
        }

        .helper {
            font-size: 12px;
            color: var(--muted)
        }

        .spacer {
            height: 12px
        }

        hr {
            border: 0;
            border-top: 1px solid var(--border);
            margin: 16px 0
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 12px;
            border: 1px solid var(--border);
            background: #0c121a;
            color: var(--muted)
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            background: #0e1420;
            border: 1px solid var(--border);
            border-bottom-color: #111826;
            border-radius: 6px;
            padding: 2px 6px;
            color: #bcd;
        }

        .link {
            color: var(--accent-2);
            text-decoration: none
        }

        .footer {
            margin-top: 28px;
            color: var(--muted);
            font-size: 12px;
            text-align: center
        }

        .notice {
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #0c1320;
            color: #cbd5e1
        }

        .entry-status {
            display: block !important;
            font-size: 12px;
            padding: 4px 8px;
            border-radius: 4px;
            margin-bottom: 8px;
            transition: all 0.2s ease;
        }

        .entry-status.new-entry {
            background: rgba(16, 185, 129, 0.1);
            color: var(--ok);
            border: 1px solid rgba(16, 185, 129, 0.2);
        }

        .entry-status.update-entry {
            background: rgba(59, 130, 246, 0.1);
            color: var(--accent);
            border: 1px solid rgba(59, 130, 246, 0.2);
        }

        .entry-status.no-change {
            background: rgba(156, 163, 175, 0.1);
            color: var(--muted);
            border: 1px solid rgba(156, 163, 175, 0.2);
        }

        .error {
            color: #fecaca
        }

        .success {
            color: #bbf7d0
        }

        .truncate {
            display: block;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis
        }

        #app-overlay {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(5, 8, 13, .92);
            color: var(--text);
            z-index: 10002
        }

        #app-overlay .box {
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px 24px;
            min-width: 260px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .5)
        }
        #toast-container {
            position: fixed;
            top: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10003;
            pointer-events: none;
        }
        .toast {
            pointer-events: auto;
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px 14px;
            color: var(--text);
            min-width: 260px;
            max-width: 360px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
            position: relative;
            opacity: 0;
            transform: translateY(-8px);
            animation: toast-in 160ms ease-out forwards;
        }
        .toast.success { border-color: rgba(16,185,129,.35); }
        .toast.error { border-color: rgba(239,68,68,.35); }
        .toast .bar {
            position: absolute;
            left: 0;
            bottom: 0;
            height: 3px;
            background: var(--accent);
            width: 100%;
            transform-origin: left;
            animation: toast-bar 3s linear forwards;
        }
        .toast.error .bar { background: var(--danger); }
        .toast.success .bar { background: var(--ok); }
        .toast.out { animation: toast-out 140ms ease-in forwards; }
        @keyframes toast-in { from { opacity: 0; transform: translateY(-8px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes toast-out { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(-8px); } }
        @keyframes toast-bar { from { transform: scaleX(1); } to { transform: scaleX(0); } }
        .highlight { background: rgba(96,165,250,.35); padding: 0 2px; border-radius: 3px; }
        .pager { display:flex; align-items:center; gap:8px; flex-wrap:wrap; margin: 8px 0; }
        .pager input[type="number"] { width: 72px; }
        /* Auth modal */
        #auth-modal { position: fixed; inset: 0; display: none; place-items: center; background: rgba(5,8,13,.72); z-index: 10001; }
        #auth-modal .auth-box { background: linear-gradient(180deg, var(--panel), var(--panel-2)); border: 1px solid var(--border); border-radius: 12px; padding: 20px 24px; width: 100%; max-width: 420px; box-shadow: 0 10px 30px rgba(0,0,0,.5); }
        #auth-modal .auth-head { display:flex; justify-content:space-between; align-items:center; margin-bottom: 8px; }
        #auth-modal .auth-close { background: transparent; border: 1px solid var(--border); color: var(--text); padding: 6px 10px; border-radius: 8px; cursor: pointer; }
        #auth-modal .auth-switch { display:flex; gap:8px; align-items:center; justify-content:center; margin-top: 8px; }
        #auth-modal .auth-switch a { cursor: pointer; color: var(--accent-2); text-decoration: none; }
        /* User menu */
        #user-menu { position: absolute; right: 24px; top: 56px; display: none; min-width: 220px; background: linear-gradient(180deg, var(--panel), var(--panel-2)); border: 1px solid var(--border); border-radius: 10px; box-shadow: 0 10px 30px rgba(0,0,0,.35); z-index: 1000; }
        #user-menu .item { padding: 10px 12px; color: var(--text); text-decoration: none; display: block; cursor: pointer; }
        #user-menu .item:hover { background: #0c1320; }
        #user-menu .muted { color: var(--muted); font-size: 12px; }
        /* OTP input styling */
        input[placeholder="123456"] {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            font-size: 18px;
            text-align: center;
            letter-spacing: 2px;
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <div class="brand">Daily Diary</div>
            <div class="nav">
                <a id="nav-home" href="#">Home</a>
                <a id="nav-public" href="#public">Public</a>
                <a id="nav-login" href="#" style="display:none">Login</a>
                <a id="nav-user" href="#" style="display:none"></a>
            </div>
        </div>

        <div id="route-view"></div>

        <div class="footer">Make By PEPSEALSEA Â©2025
        </div>
    </div>
    <div id="app-overlay" style="display: grid;">
        <div class="box">
            <div id="app-overlay-title" style="font-weight:600;margin-bottom:6px">Loadingâ€¦</div>
            <div id="app-overlay-helper" class="helper">Preparing your diary</div>
        </div>
    </div>
    <div id="toast-container" aria-live="polite" aria-atomic="true"></div>

    <div id="auth-modal" aria-modal="true" role="dialog">
        <div class="auth-box">
            <div class="auth-head">
                <div id="auth-modal-title" style="font-weight:600">Login</div>
                <button id="auth-close" class="auth-close">Close</button>
            </div>
            <div id="auth-modal-body">
                <div id="auth-login-form">
                    <label>Username or Email</label>
                    <input id="modal-login-identifier" placeholder="you@example.com or username" />
                    <div class="spacer"></div>
                    <label>Password</label>
                    <input id="modal-login-password" type="password" />
                    <div class="spacer"></div>
                    <div id="login-otp-section" style="display:none">
                        <label>OTP Code (6 digits)</label>
                        <input id="modal-login-otp" placeholder="123456" maxlength="6" />
                        <div class="spacer"></div>
                        <button id="modal-btn-resend-otp" class="ghost" style="width:100%">Resend OTP</button>
                        <div class="spacer"></div>
                    </div>
                    <button id="modal-btn-login" style="width:100%">Login</button>
                    <div class="spacer"></div>
                    <div class="auth-switch helper">No account? <a id="switch-to-register">Register</a></div>
                    <div class="spacer"></div>
                    <span class="helper" id="modal-auth-msg"></span>
                </div>
                <div id="auth-register-form" style="display:none">
                    <label>Email</label>
                    <input id="modal-reg-email" placeholder="you@example.com" />
                    <div class="spacer"></div>
                    <label>Username</label>
                    <input id="modal-reg-username" placeholder="yourname" />
                    <div class="spacer"></div>
                    <label>Password</label>
                    <input id="modal-reg-password" type="password" />
                    <div class="spacer"></div>
                    <div id="register-otp-section" style="display:none">
                        <label>OTP Code (6 digits)</label>
                        <input id="modal-reg-otp" placeholder="123456" maxlength="6" />
                        <div class="spacer"></div>
                        <button id="modal-btn-resend-reg-otp" class="ghost" style="width:100%">Resend OTP</button>
                        <div class="spacer"></div>
                    </div>
                    <button id="modal-btn-register" style="width:100%">Create account</button>
                    <div class="spacer"></div>
                    <div class="auth-switch helper">Have an account? <a id="switch-to-login">Login</a></div>
                    <div class="spacer"></div>
                    <span class="helper" id="modal-auth-msg-reg"></span>
                </div>
                <!-- Dedicated OTP verification view -->
                <div id="otp-verify-view" style="display:none">
                    <div id="otp-title" style="font-weight:600;margin-bottom:6px">Verify your email</div>
                    <div class="helper" id="otp-subtitle" style="margin-bottom:12px"></div>
                    <label>OTP Code (6 digits)</label>
                    <input id="otp-input" placeholder="123456" maxlength="6" />
                    <div class="spacer"></div>
                    <button id="otp-verify-btn" style="width:100%">Verify</button>
                    <div class="spacer"></div>
                    <button id="otp-resend-btn" class="ghost" style="width:100%">Resend OTP</button>
                    <div class="spacer"></div>
                    <div class="auth-switch helper">Wrong email? <a id="otp-change-email">Change email</a></div>
                    <div class="spacer"></div>
                    <span class="helper" id="otp-msg"></span>
                </div>
            </div>
        </div>
    </div>
    <div id="user-menu" role="menu" aria-hidden="true">
        <div class="item" id="menu-friends">Friends</div>
        <div class="item" id="menu-logout">Logout</div>
        <div class="item muted" id="menu-last-online" style="display:none"></div>
    </div>

    <script>
        // Show loading overlay immediately when page loads
        document.addEventListener('DOMContentLoaded', function() {
            const overlay = document.getElementById('app-overlay');
            if (overlay) {
                overlay.style.display = 'grid';
                const title = document.getElementById('app-overlay-title');
                const helper = document.getElementById('app-overlay-helper');
                if (title) title.textContent = 'Loadingâ€¦';
                if (helper) helper.textContent = 'Preparing your diary';
            }
        });

        (function () {
            const API_URL = 'https://script.google.com/macros/s/AKfycbxR7BQFNg_LHPspcMYXLpdwMQ6Ql6fzr1DVDryXCYdW4aPJlvb4oXFPx-Tng4ofmQLvmw/exec';
            const OTP_API_URL = 'https://script.google.com/macros/s/AKfycbzEBBDzJvZvCWYJsoa0HwPwrPWu0AQAbnj8d0uUUNY2xYcFXiIagSsD1GEmHvKgLT5Q2w/exec';
            const storage = {
                set(k, v, days) {
                    const value = typeof v === 'string' ? v : JSON.stringify(v);
                    const expires = days ? "; max-age=" + (days * 24 * 60 * 60) : '';
                    document.cookie = encodeURIComponent(k) + "=" + encodeURIComponent(value) + expires + "; path=/";
                },
                get(k) {
                    const name = encodeURIComponent(k) + "=";
                    const parts = document.cookie.split('; ');
                    for (const p of parts) {
                        if (p.startsWith(name)) {
                            const val = decodeURIComponent(p.substring(name.length));
                            try { return JSON.parse(val); } catch { return val; }
                        }
                    }
                    return null;
                },
                del(k) {
                    document.cookie = encodeURIComponent(k) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
                }
            };

            const auth = {
                get user() { return storage.get('diary_user'); },
                set user(u) { if (u) storage.set('diary_user', u, 30); else storage.del('diary_user'); }
            };
            function viewerEmail() { return (auth.user && auth.user.email) ? auth.user.email : ''; }

            // Function to update cache after entry operations
            function updateCacheAfterEntryOperation(operation, entryData) {
                if (!clientCache.userLoadedAll || !clientCache.userEntries) return;
                
                switch (operation) {
                    case 'save':
                        // Add new entry to cache
                        clientCache.userEntries.unshift(entryData);
                        const list = clientCache.userEntriesByDate[entryData.date] || (clientCache.userEntriesByDate[entryData.date] = []);
                        list.unshift(entryData);
                        if (clientCache.userEmptyDates) clientCache.userEmptyDates.delete(entryData.date);
                        break;
                        
                    case 'update':
                        // Update existing entry in cache
                        for (let i = 0; i < clientCache.userEntries.length; i++) {
                            if (clientCache.userEntries[i].entryId === entryData.entryId) {
                                Object.assign(clientCache.userEntries[i], entryData);
                                break;
                            }
                        }
                        if (clientCache.userEntriesByDate[entryData.date]) {
                            for (let i = 0; i < clientCache.userEntriesByDate[entryData.date].length; i++) {
                                if (clientCache.userEntriesByDate[entryData.date][i].entryId === entryData.entryId) {
                                    Object.assign(clientCache.userEntriesByDate[entryData.date][i], entryData);
                                    break;
                                }
                            }
                        }
                        break;
                        
                    case 'delete':
                        // Remove entry from cache
                        clientCache.userEntries = clientCache.userEntries.filter(e => e.entryId !== entryData.entryId);
                        if (clientCache.userEntriesByDate[entryData.date]) {
                            clientCache.userEntriesByDate[entryData.date] = clientCache.userEntriesByDate[entryData.date].filter(e => e.entryId !== entryData.entryId);
                            if (clientCache.userEntriesByDate[entryData.date].length === 0) {
                                delete clientCache.userEntriesByDate[entryData.date];
                                if (clientCache.userEmptyDates) clientCache.userEmptyDates.add(entryData.date);
                            }
                        }
                        break;
                }
            }

            // Centralized function to ensure user data is loaded once and cached
            async function ensureUserDataLoaded(force = false) {
                const user = auth.user;
                if (!user) return false;
                
                // Check if we already have fresh data (less than 5 minutes old)
                const now = Date.now();
                const isDataFresh = clientCache.userLoadedAll && 
                                  clientCache.userEntries && 
                                  (now - clientCache.lastFetchTime) < 300000; // 5 minutes
                
                if (isDataFresh && !force) {
                    return true; // Data is already loaded and fresh
                }
                
                // Prevent multiple simultaneous fetches
                if (clientCache.fetchInProgress) {
                    // Wait for the current fetch to complete
                    while (clientCache.fetchInProgress) {
                        await new Promise(resolve => setTimeout(resolve, 100));
                    }
                    return clientCache.userLoadedAll;
                }
                
                try {
                    clientCache.fetchInProgress = true;
                    console.log('Fetching all user entries...');
                    
                    const res = await apiGet({ action: 'getUserDiaryEntries', userId: user.id });
                    if (res.success && Array.isArray(res.entries)) {
                        clientCache.userEntries = res.entries;
                        clientCache.userEntriesByDate = {};
                        clientCache.userEmptyDates.clear();
                        
                        // Organize entries by date for instant lookup
                        for (const e of res.entries) {
                            const list = clientCache.userEntriesByDate[e.date] || (clientCache.userEntriesByDate[e.date] = []);
                            list.push(e);
                        }
                        
                        clientCache.userLoadedAll = true;
                        clientCache.lastFetchTime = now;
                        console.log(`Loaded ${res.entries.length} entries into cache`);
                        return true;
                    } else {
                        console.error('Failed to load user entries:', res.error);
                        return false;
                    }
                } catch (error) {
                    console.error('Error loading user data:', error);
                    return false;
                } finally {
                    clientCache.fetchInProgress = false;
                }
            }

            function q(sel, root = document) { return root.querySelector(sel); }
            function el(html) { const t = document.createElement('template'); t.innerHTML = html.trim(); return t.content.firstChild; }
            const clientCache = {
                userEntries: null, // Array of all entries for logged-in user
                userEntriesByDate: {}, // date -> entries[]
                userLoadedAll: false,
                userEmptyDates: new Set(), // dates confirmed to have no private entry
                publicByUser: new Map(), // username -> {entries: [], byDate: {}, emptyDates: Set}
                lastFetchTime: 0, // Track when data was last fetched
                fetchInProgress: false, // Prevent multiple simultaneous fetches
            };
            function fmtDate(d) {
                const x = new Date(d);
                const y = x.getFullYear();
                const m = String(x.getMonth() + 1).padStart(2, '0');
                const day = String(x.getDate()).padStart(2, '0');
                return y + '-' + m + '-' + day; // local date, not UTC
            }
            function today() { return fmtDate(new Date()); }
            function toDisplayDate(iso) {
                // iso: YYYY-MM-DD -> DD-MM-YYYY
                if (!iso || !/^\d{4}-\d{2}-\d{2}$/.test(iso)) return iso || '';
                const [y, m, d] = iso.split('-');
                return d + '-' + m + '-' + y;
            }
            function toIsoDate(maybe) {
                // Accept DD-MM-YYYY or YYYY-MM-DD and normalize to ISO
                if (!maybe) return '';
                if (/^\d{4}-\d{2}-\d{2}$/.test(maybe)) return maybe;
                const m = maybe.match(/^(\d{2})-(\d{2})-(\d{4})$/);
                if (m) return m[3] + '-' + m[2] + '-' + m[1];
                return fmtDate(maybe);
            }
            function privacyIcon(p) {
                const v = String(p || '').toLowerCase();
                if (v === 'public') return 'ðŸŒ';
                if (v === 'friend') return 'â˜…';
                if (v === 'private') return 'ðŸ”’';
                return '';
            }
            function normalizePrivacyValue(privacyValue, legacyIsPrivate) {
                const v = (privacyValue !== undefined && privacyValue !== null) ? String(privacyValue).toLowerCase() : null;
                if (v === 'public' || v === 'friend' || v === 'private') return v;
                if (v === 'true') return 'private';
                if (v === 'false') return 'public';
                const lv = (legacyIsPrivate !== undefined && legacyIsPrivate !== null) ? String(legacyIsPrivate).toLowerCase() : null;
                if (lv === 'public' || lv === 'friend' || lv === 'private') return lv;
                if (typeof legacyIsPrivate === 'boolean') return legacyIsPrivate ? 'private' : 'public';
                if (lv === 'true') return 'private';
                if (lv === 'false') return 'public';
                if (legacyIsPrivate === true) return 'private';
                if (legacyIsPrivate === false) return 'public';
                return 'public';
            }
            function addDaysIso(iso, delta) {
                const d = new Date(toIsoDate(iso));
                d.setDate(d.getDate() + delta);
                return fmtDate(d);
            }
            function basePath() {
                const segs = location.pathname.split('/').filter(Boolean);
                return segs.length ? '/' + segs[0] : '';
            }

            async function apiGet(params) {
                if (!API_URL) { throw new Error('API URL not configured'); }
                const merged = Object.assign({}, params);
                if (merged && (merged.action === 'getDiaryEntry' || merged.action === 'getPublicDiaryEntries')) {
                    if (viewerEmail()) merged.viewerEmail = viewerEmail();
                }
                const qs = new URLSearchParams(merged).toString();
                const res = await fetch(API_URL + '?' + qs, { method: 'GET' });
                return res.json();
            }
            async function apiPost(params) {
                if (!API_URL) { throw new Error('API URL not configured'); }
                const merged = Object.assign({}, params);
                if (merged && (merged.action === 'getDiaryEntry' || merged.action === 'getPublicDiaryEntries')) {
                    if (viewerEmail()) merged.viewerEmail = viewerEmail();
                }
                const form = new URLSearchParams(merged);
                const res = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: form.toString() });
                return res.json();
            }

            // OTP service functions - direct calls
            async function otpApiGet(params) {
                if (!OTP_API_URL) { throw new Error('OTP API URL not configured'); }
                const qs = new URLSearchParams(params).toString();
                const res = await fetch(OTP_API_URL + '?' + qs, { method: 'GET' });
                return res.json();
            }
            async function otpApiPost(params) {
                if (!OTP_API_URL) { throw new Error('OTP API URL not configured'); }
                const form = new URLSearchParams(params);
                const res = await fetch(OTP_API_URL, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: form.toString() });
                return res.json();
            }

            function show(elm) { elm.style.display = ''; }
            function hide(elm) { elm.style.display = 'none'; }
            function hideOverlay() { const o = q('#app-overlay'); if (o) o.style.display = 'none'; }
            function showOverlay(title, helper) {
                const o = q('#app-overlay'); if (!o) return;
                const t = q('#app-overlay-title');
                const h = q('#app-overlay-helper');
                if (t) t.textContent = title || 'Workingâ€¦';
                if (h) h.textContent = helper || '';
                o.style.display = 'grid';
            }

            let __lastToast = { text: '', time: 0 };
            function toast(text, ok, force) {
                const host = q('#toast-container') || (() => { const d = document.createElement('div'); d.id = 'toast-container'; document.body.appendChild(d); return d; })();
                const now = Date.now();
                const msgText = String(text || '');
                if (!force && __lastToast.text === msgText && (now - __lastToast.time) < 1500) {
                    return null;
                }
                __lastToast = { text: msgText, time: now };
                const t = document.createElement('div');
                t.className = 'toast ' + (ok ? 'success' : 'error');
                t.setAttribute('role', 'status');
                t.setAttribute('aria-live', 'polite');
                const content = document.createElement('div');
                content.textContent = msgText;
                const bar = document.createElement('div');
                bar.className = 'bar';
                t.appendChild(content);
                t.appendChild(bar);
                host.appendChild(t);
                let removed = false;
                function removeToast() {
                    if (removed) return; removed = true;
                    t.classList.add('out');
                    setTimeout(() => { if (t.parentNode) t.parentNode.removeChild(t); }, 180);
                }
                const timer = setTimeout(removeToast, 3000);
                t.addEventListener('click', () => { clearTimeout(timer); removeToast(); });
                return t;
            }

            function updateNavVisibility() {
                const nl = q('#nav-login');
                const nu = q('#nav-user');
                if (auth.user) {
                    if (nl) nl.style.display = 'none';
                    if (nu) { nu.style.display = 'inline'; nu.textContent = auth.user.username; }
                } else {
                    if (nu) nu.style.display = 'none';
                    if (nl) nl.style.display = 'inline';
                }
            }

            function render() {
                const mount = q('#route-view');
                mount.innerHTML = '';

                // Show loading overlay by default
                showOverlay('Loadingâ€¦', 'Preparing your diary');

                const qp = new URLSearchParams(window.location.search);
                const pathParam = qp.get('path');
                const rawPath = pathParam || window.location.pathname;
                const trimmed = rawPath.replace(new RegExp('^' + basePath().replace(/[.*+?^${}()|[\]\\]/g, '\\$&')), '');
                const path = trimmed.replace(/^\/+|\/+$/g, '');
                // If we arrived via 404.html redirect (?path=...), replace URL with clean path for user friendliness
                if (pathParam) {
                    const newUrl = basePath() + (path ? '/' + path : '');
                    const hash = window.location.hash || '';
                    history.replaceState({}, '', newUrl + hash);
                }
                const segments = path.split('/').filter(Boolean);
                const last = segments.slice(-2);
                const maybeUser = last.length === 2 ? last[0] : null;
                const maybeDate = last.length === 2 ? last[1] : null;
                const maybeUserOnly = segments.length === 1 ? segments[0] : null;

                const hash = window.location.hash || '';
                updateNavVisibility();
                if (hash.startsWith('#public')) {
                    const n = PublicList();
                    hideOverlay();
                    return mount.appendChild(n);
                }

                if (maybeUser && /^(?:\d{4}-\d{2}-\d{2}|\d{2}-\d{2}-\d{4})$/.test(maybeDate)) {
                    const n = PublicEntry(maybeUser, toIsoDate(maybeDate));
                    // overlay will be hidden by PublicEntry after first fetch
                    return mount.appendChild(n);
                }

                // Route: /:username â†’ public calendar for that user
                if (maybeUserOnly && !/^\d{4}-\d{2}-\d{2}$/.test(maybeUserOnly)) {
                    const n = PublicUser(maybeUserOnly);
                    // overlay will be hidden after initial calendar render
                    return mount.appendChild(n);
                }

                if (auth.user) {
                    updateNavVisibility();
                    const n = Dashboard();
                    // overlay will be hidden inside once initial load completes
                    return mount.appendChild(n);
                } else {
                    updateNavVisibility();
                    hideOverlay();
                    // Open popup login for simpler flow on home
                    openAuthModal('login');
                    const n = el(`
      <div class="card" style="max-width:560px;margin:0 auto;">
        <h3 style="margin-top:0;margin-bottom:8px;">Welcome</h3>
        <div class="helper" style="margin-bottom:12px;">Please login to write your diary. You can also browse public posts.</div>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="home-login-btn">Open login</button>
          <a id="home-view-public" class="ghost" href="#public">View public</a>
        </div>
      </div>
    `);
                    mount.appendChild(n);
                    const btn = n.querySelector('#home-login-btn'); if (btn) btn.addEventListener('click', () => openAuthModal('login'));
                    const viewPub = n.querySelector('#home-view-public'); if (viewPub) viewPub.addEventListener('click', (e) => { e.preventDefault(); location.hash = 'public'; });
                    return;
                }
            }

            // Modal helpers
            function openAuthModal(mode) {
                const modal = q('#auth-modal');
                if (!modal) return;
                const loginForm = q('#auth-login-form');
                const regForm = q('#auth-register-form');
                const title = q('#auth-modal-title');
                
                // Reset OTP sections
                const loginOtpSection = q('#login-otp-section');
                const regOtpSection = q('#register-otp-section');
                if (loginOtpSection) loginOtpSection.style.display = 'none';
                if (regOtpSection) regOtpSection.style.display = 'none';
                // Hide dedicated OTP view
                const otpView = q('#otp-verify-view');
                if (otpView) otpView.style.display = 'none';
                
                // Clear OTP inputs
                const loginOtpInput = q('#modal-login-otp');
                const regOtpInput = q('#modal-reg-otp');
                if (loginOtpInput) loginOtpInput.value = '';
                if (regOtpInput) regOtpInput.value = '';
                
                // Clear messages
                const loginMsg = q('#modal-auth-msg');
                const regMsg = q('#modal-auth-msg-reg');
                if (loginMsg) { loginMsg.textContent = ''; loginMsg.className = 'helper'; }
                if (regMsg) { regMsg.textContent = ''; regMsg.className = 'helper'; }
                
                if (mode === 'register') {
                    if (title) title.textContent = 'Register';
                    if (loginForm) loginForm.style.display = 'none';
                    if (regForm) regForm.style.display = '';
                } else {
                    if (title) title.textContent = 'Login';
                    if (loginForm) loginForm.style.display = '';
                    if (regForm) regForm.style.display = 'none';
                }
                modal.style.display = 'grid';
            }
            function closeAuthModal() {
                const modal = q('#auth-modal');
                if (modal) modal.style.display = 'none';
            }

            function AuthPage() {
                const node = el(`
      <div class="row">
        <div class="col" style="flex:1 1 480px;">
          <div class="card" style="max-width:560px;margin:0 auto;">
            <h3 style="margin-top:0;margin-bottom:8px;">Welcome back</h3>
            <div class="helper" style="margin-bottom:12px;">Login to write your diary. New here? Create an account below.</div>
            <label>Username or Email</label>
            <input id="login-identifier" placeholder="you@example.com or username" />
            <div class="spacer"></div>
            <label>Password</label>
            <input id="login-password" type="password" />
            <div class="spacer"></div>
            <button id="btn-login" style="width:100%;">Login</button>
            <div class="spacer"></div>
            <div class="helper">No account?</div>
            <div class="spacer" style="height:8px"></div>
            <label>Email</label>
            <input id="reg-email" placeholder="you@example.com" />
            <div class="spacer"></div>
            <label>Username</label>
            <input id="reg-username" placeholder="yourname" />
            <div class="spacer"></div>
            <label>Password</label>
            <input id="reg-password" type="password" />
            <div class="spacer"></div>
            <button id="btn-register" class="ghost" style="width:100%;">Create account</button>
            <div class="spacer"></div>
            <span class="helper" id="auth-msg"></span>
          </div>
        </div>
      </div>
    `);

                node.querySelector('#btn-login').addEventListener('click', async () => {
                    const identifier = node.querySelector('#login-identifier').value.trim();
                    const password = node.querySelector('#login-password').value;
                    const msg = node.querySelector('#auth-msg');
                    msg.textContent = '';
                    showOverlay('Logging inâ€¦', 'Please wait');
                    try {
                        const res = await apiPost({ action: 'login', identifier, password });
                        if (res.success) {
                            auth.user = res.user; // {id,email,username}
                            render();
                        } else {
                            msg.textContent = res.error || res.message || 'Login failed';
                            msg.className = 'helper error';
                        }
                    } catch (e) { msg.textContent = e.message; msg.className = 'helper error'; }
                    finally { hideOverlay(); }
                });

                node.querySelector('#btn-register').addEventListener('click', async () => {
                    const email = node.querySelector('#reg-email').value.trim();
                    const username = node.querySelector('#reg-username').value.trim();
                    const password = node.querySelector('#reg-password').value;
                    const msg = node.querySelector('#auth-msg');
                    msg.textContent = '';
                    showOverlay('Creating accountâ€¦', 'Please wait');
                    try {
                        if (username.length < 5 || username.length > 20) {
                            msg.textContent = 'Username must be 5-20 characters';
                            msg.className = 'helper error';
                            hideOverlay();
                            return;
                        }
                        const res = await apiPost({ action: 'register', email, username, password });
                        if (res.success) {
                            // Auto-login after successful registration
                            try {
                                const loginRes = await apiPost({ action: 'login', identifier: email || username, password });
                                if (loginRes.success) {
                                    auth.user = loginRes.user;
                                    render();
                                } else {
                                    msg.textContent = (loginRes.error || 'Registered, but auto-login failed. Please try logging in.');
                                    msg.className = 'helper error';
                                }
                            } catch (e) {
                                msg.textContent = 'Registered, but auto-login failed: ' + e.message;
                                msg.className = 'helper error';
                            }
                        } else {
                            msg.textContent = res.error || res.message || 'Registration failed';
                            msg.className = 'helper error';
                        }
                    } catch (e) { msg.textContent = e.message; msg.className = 'helper error'; }
                    finally { hideOverlay(); }
                });

                return node;
            }

            function Dashboard() {
                const user = auth.user;
                const node = el(`
      <div class="row">
        <div class="col">
          <div class="card">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
              <div>
                <h3>My Diary</h3>
                <div class="helper">Logged in as <span class="badge">${user.username}</span></div>
              </div>
              <div class="helper">Public: <span class="kbd">/${user.username}/DD-MM-YYYY</span></div>
            </div>
            <div class="spacer"></div>
            <div style="display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap">
              <button id="tab-editor">Editor</button>
              <button id="tab-calendar" class="ghost">Calendar</button>
              <button id="btn-edit" class="ghost">Edit</button>
            </div>
            <div id="section-editor">
            <label>Date</label>
            <input id="diary-date" type="date" value="${today()}" />
            <div class="spacer" style="height:8px"></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btn-prev-day" class="ghost">Prev day</button>
              <button id="btn-next-day" class="ghost">Next day</button>
              <button id="btn-refresh" class="ghost">Refresh</button>
            </div>
            <div class="spacer"></div>
            <label>Entry <span id="title-privacy-icon" class="helper" style="margin-left:6px"></span></label>
            <div style="display:flex;gap:8px;flex-wrap:wrap;align-items:center">
              <select id="diary-entry-select" style="min-width:220px"></select>
              <button id="btn-new-entry" class="ghost">New entry</button>
            </div>
            <div class="spacer"></div>
            <label>Title</label>
            <input id="diary-title" placeholder="Title for this entry" />
            <div class="spacer"></div>
            <label>Content</label>
            <textarea id="diary-content" placeholder="Write your day..."></textarea>
            <div class="spacer"></div>
            <label>Privacy</label>
            <select id="diary-private">
              <option value="public">Public (anyone)</option>
              <option value="friend">Friend (approved users)</option>
              <option value="private">Private (only you)</option>
            </select>
            <div class="spacer"></div>
            <div id="entry-status" class="entry-status no-change" style="font-size:12px;padding:4px 8px;border-radius:4px;margin-bottom:8px;display:none;">
              No changes detected
            </div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btn-save">Save</button>
              <button id="btn-update" class="ghost">Update</button>
              <button id="btn-delete" class="danger">Delete</button>
              <a id="permalink" class="link" target="_blank" rel="noopener">Open public link</a>
            </div>
            <div class="spacer"></div>
            <div id="dash-msg" class="notice" style="display:none"></div>
            <div id="autosave-indicator" class="helper" style="display:none;color:var(--accent-2);font-size:11px;margin-top:8px;">
              <span id="autosave-status">Auto-save active</span>
            </div>
            </div>
            <div id="section-calendar" style="display:none">
              <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px">
                <button id="cal-prev" class="ghost">Prev</button>
                <div id="cal-label" class="badge"></div>
                <button id="cal-next" class="ghost">Next</button>
              </div>
              <div id="calendar"></div>
            </div>
          </div>
        </div>
        <div class="col">
          <div class="card">
            <h3>Recent entries</h3>
            <div id="recent-controls" class="pager" style="display:none">
              <button id="recent-prev" class="ghost" title="Previous page">â—€</button>
              <span class="helper">Page</span>
              <input id="recent-page-input" type="number" min="1" value="1" />
              <span id="recent-page-total" class="helper">/ 1</span>
              <button id="recent-next" class="ghost" title="Next page">â–¶</button>
            </div>
            <div id="recent-list" class="helper">Loadingâ€¦</div>
          </div>
        </div>
      </div>
    `);

                const dateInput = node.querySelector('#diary-date');
                const titleInput = node.querySelector('#diary-title');
                const entrySelect = node.querySelector('#diary-entry-select');
                const btnNewEntry = node.querySelector('#btn-new-entry');
                const contentInput = node.querySelector('#diary-content');
                const privacySelect = node.querySelector('#diary-private');
                const msg = node.querySelector('#dash-msg');
                const permalink = node.querySelector('#permalink');
                const tabEditor = node.querySelector('#tab-editor');
                const tabCalendar = node.querySelector('#tab-calendar');
                const secEditor = node.querySelector('#section-editor');
                const secCalendar = node.querySelector('#section-calendar');
                const btnEdit = node.querySelector('#btn-edit');
                const btnRefresh = node.querySelector('#btn-refresh');
                const titlePrivacyIcon = node.querySelector('#title-privacy-icon');

                function setMsg(text, ok, quiet) { try { if (!quiet) toast(text, ok); } catch (e) {} msg.textContent = ''; msg.style.display = 'none'; }
                function clearMsg() { msg.textContent = ''; msg.style.display = 'none'; }

                function updateTitleIconFromPrivacy() {
                    const icon = privacyIcon(privacySelect.value);
                    if (titlePrivacyIcon) {
                        titlePrivacyIcon.textContent = icon;
                        titlePrivacyIcon.title = (privacySelect.value || 'public');
                    }
                }

                function setPrivacyValueSafe(value, legacyIsPrivate) {
                    const normalized = normalizePrivacyValue(value, legacyIsPrivate);
                    privacySelect.value = normalized;
                    updateTitleIconFromPrivacy();
                }

                function setPermalink() {
                    const d = dateInput.value || today();
                    const base = window.location.origin + basePath();
                    const display = toDisplayDate(d);
                    permalink.href = base + '/' + encodeURIComponent(user.username) + '/' + display;
                    permalink.textContent = permalink.href;
                }
                setPermalink();
                updateTitleIconFromPrivacy();

                // Tabs
                function showEditor() { secEditor.style.display = ''; secCalendar.style.display = 'none'; tabEditor.classList.remove('ghost'); tabCalendar.classList.add('ghost'); }
                function showCalendar() { secEditor.style.display = 'none'; secCalendar.style.display = ''; tabEditor.classList.add('ghost'); tabCalendar.classList.remove('ghost'); }
                tabEditor.addEventListener('click', showEditor);
                tabCalendar.addEventListener('click', showCalendar);
                privacySelect.addEventListener('change', updateTitleIconFromPrivacy);

                // Edit mode toggle (read-only by default)
                let editMode = false;
                let currentHasEntry = false;
                let currentEntryId = null;
                let lastSavedSnapshot = { title: '', content: '', privacy: 'public', date: dateInput.value };
                let autosaveTimer = null;
                let autosaveInFlight = false;
                let lastAutosaveTime = null;
                let statusUpdateTimer = null;
                function applyEditMode() {
                    const disabled = !editMode;
                    titleInput.disabled = disabled;
                    contentInput.disabled = disabled;
                    privacySelect.disabled = disabled;
                    dateInput.disabled = false; // allow switching date even in view mode
                    q('#btn-save', node).style.display = editMode ? (currentEntryId ? 'none' : '') : 'none';
                    q('#btn-update', node).style.display = editMode ? (currentEntryId ? '' : 'none') : 'none';
                    q('#btn-delete', node).style.display = editMode ? (currentEntryId ? '' : 'none') : 'none';
                    btnEdit.textContent = editMode ? 'Done' : 'Edit';
                    
                    // Show/hide autosave indicator
                    const autosaveIndicator = q('#autosave-indicator', node);
                    if (editMode) {
                        autosaveIndicator.style.display = 'block';
                        if (!autosaveTimer) autosaveTimer = setInterval(() => tryAutoSave(false, false), 5000);
                        if (!statusUpdateTimer) statusUpdateTimer = setInterval(updateAutosaveStatus, 1000);
                    } else {
                        autosaveIndicator.style.display = 'none';
                        if (autosaveTimer) { clearInterval(autosaveTimer); autosaveTimer = null; }
                        if (statusUpdateTimer) { clearInterval(statusUpdateTimer); statusUpdateTimer = null; }
                    }
                }
                btnEdit.addEventListener('click', async () => {
                    const wasEditing = editMode;
                    editMode = !editMode;
                    if (wasEditing && !editMode) {
                        await tryAutoSave(true, true);
                    }
                    applyEditMode();
                });
                applyEditMode();

                function isDirty() {
                    return (
                        lastSavedSnapshot.title !== titleInput.value ||
                        lastSavedSnapshot.content !== contentInput.value ||
                        String(lastSavedSnapshot.privacy) !== String(privacySelect.value) ||
                        lastSavedSnapshot.date !== (dateInput.value || today())
                    );
                }

                function updateAutosaveStatus() {
                    const statusEl = q('#autosave-status', node);
                    if (lastAutosaveTime) {
                        const timeAgo = Math.floor((Date.now() - lastAutosaveTime) / 1000);
                        if (timeAgo < 60) {
                            statusEl.textContent = `Auto-saved ${timeAgo}s ago`;
                        } else {
                            statusEl.textContent = `Auto-saved ${Math.floor(timeAgo / 60)}m ago`;
                        }
                    } else {
                        statusEl.textContent = 'Auto-save active';
                    }
                }

                async function tryAutoSave(force, showBusy) {
                    if (autosaveInFlight) return;
                    if (!force && !editMode) return;
                    if (!force && !isDirty()) return;
                    const hasContent = (contentInput.value || '').trim().length > 0;
                    const hasTitle = (titleInput.value || '').trim().length > 0;
                    const creatingNewEmpty = !currentHasEntry && !hasTitle && !hasContent;
                    if (!force && creatingNewEmpty) return;
                    if (creatingNewEmpty && force) {
                        // Leaving edit mode with nothing typed and no existing entry: do nothing
                        return;
                    }
                    autosaveInFlight = true;
                    try {
                        if (currentEntryId) {
                            await update(!!showBusy);
                            if (force) setMsg('Auto-saved at ' + new Date().toLocaleTimeString(), true);
                        } else {
                            await save(!!showBusy);
                            currentHasEntry = true;
                            if (force) setMsg('Auto-saved at ' + new Date().toLocaleTimeString(), true);
                        }
                        lastSavedSnapshot = { title: titleInput.value, content: contentInput.value, privacy: privacySelect.value, date: dateInput.value || today() };
                        lastAutosaveTime = Date.now();
                        updateAutosaveStatus();
                    } catch (e) {
                        if (force) setMsg('Auto-save failed: ' + e.message, false);
                    } finally {
                        autosaveInFlight = false;
                    }
                }

                // Calendar
                let calYear = new Date().getFullYear();
                let calMonth = new Date().getMonth(); // 0-11
                const calLabel = node.querySelector('#cal-label');
                const calPrev = node.querySelector('#cal-prev');
                const calNext = node.querySelector('#cal-next');
                const calHost = node.querySelector('#calendar');

                calPrev.addEventListener('click', () => { calMonth--; if (calMonth < 0) { calMonth = 11; calYear--; } renderCalendar(); });
                calNext.addEventListener('click', () => { calMonth++; if (calMonth > 11) { calMonth = 0; calYear++; } renderCalendar(); });

                async function renderCalendar() {
                    const first = new Date(calYear, calMonth, 1);
                    const monthStr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0');
                    calLabel.textContent = first.toLocaleString(undefined, { month: 'long', year: 'numeric' });
                    calHost.innerHTML = '';
                    const grid = document.createElement('div');
                    grid.style.display = 'grid';
                    grid.style.gridTemplateColumns = 'repeat(7,1fr)';
                    grid.style.gap = '8px';
                    const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    weekdays.forEach(d => { const h = document.createElement('div'); h.className = 'helper'; h.textContent = d; grid.appendChild(h); });
                    const startPad = first.getDay();
                    const daysInMonth = new Date(calYear, calMonth + 1, 0).getDate();
                    for (let i = 0; i < startPad; i++) { const pad = document.createElement('div'); grid.appendChild(pad); }
                    
                    // Ensure user data is loaded first
                    await ensureUserDataLoaded();
                    
                    let entriesByDate = {};
                    // Use cached data for instant rendering
                    if (clientCache.userLoadedAll && clientCache.userEntries) {
                        for (const e of clientCache.userEntries) {
                            if (!e.date.startsWith(monthStr)) continue;
                            const list = entriesByDate[e.date] || (entriesByDate[e.date] = []);
                            list.push(e);
                        }
                    } else if (clientCache.userEntriesByDate) {
                        // Use preloaded by-date data for instant rendering
                        for (const date in clientCache.userEntriesByDate) {
                            if (!date.startsWith(monthStr)) continue;
                            entriesByDate[date] = clientCache.userEntriesByDate[date];
                        }
                    }
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dstr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                        const cell = document.createElement('div');
                        cell.style.border = '1px solid var(--border)';
                        cell.style.borderRadius = '10px';
                        cell.style.padding = '8px';
                        cell.style.minHeight = '72px';
                        cell.style.height = '96px';
                        cell.style.overflow = 'hidden';
                        cell.style.display = 'flex';
                        cell.style.flexDirection = 'column';
                        cell.style.background = 'var(--input)';
                        const head = document.createElement('div'); head.className = 'helper'; head.textContent = day; cell.appendChild(head);
                        const list = entriesByDate[dstr] || [];
                        const count = list.length;
                        if (count > 0) {
                            const a = document.createElement('a'); a.className = 'link truncate'; a.href = `${basePath()}/${encodeURIComponent(user.username)}/${toDisplayDate(dstr)}`; a.target = '_blank'; a.rel = 'noopener';
                            const first = list[0];
                            const pval = normalizePrivacyValue(first.privacy, first.isPrivate);
                            const label = pval === 'friend' ? ' (friend)' : (pval === 'private' ? ' (private)' : '');
                            a.textContent = (first.title || 'Untitled') + label;
                            a.title = (first.title || 'Untitled') + label;
                            try { cell.title = list.map(e => { const pv = e.privacy || (e.isPrivate === true || e.isPrivate === 'true' ? 'private' : 'public'); const lb = pv === 'friend' ? ' (friend)' : (pv === 'private' ? ' (private)' : ''); return (e.title || 'Untitled') + lb; }).join('\n'); } catch (e) {}
                            const p = document.createElement('div'); p.style.marginTop = '6px'; p.appendChild(a); cell.appendChild(p);
                            const badge = document.createElement('span'); badge.className = 'badge'; badge.textContent = String(count);
                            badge.style.float = 'right';
                            head.appendChild(badge);
                        } else {
                            const p = document.createElement('div'); p.className = 'helper'; p.style.marginTop = '6px'; p.textContent = 'â€”'; cell.appendChild(p);
                        }
                        cell.addEventListener('click', () => { dateInput.value = dstr; showEditor(); setPermalink(); load(false); });
                        grid.appendChild(cell);
                    }
                    calHost.appendChild(grid);
                    // Hide overlay after first calendar paint
                    hideOverlay();
                }

                // default to Editor; user can open Calendar tab
                renderCalendar();

                let recentAll = [];
                let recentPage = 1;
                const recentPageSize = 10;
                const recentWrap = node.querySelector('#recent-list');
                const recentControls = node.querySelector('#recent-controls');
                const recentPrev = node.querySelector('#recent-prev');
                const recentNext = node.querySelector('#recent-next');
                const recentPageInput = node.querySelector('#recent-page-input');
                const recentPageTotal = node.querySelector('#recent-page-total');

                function renderRecent() {
                    const total = recentAll.length;
                    const totalPages = Math.max(1, Math.ceil(total / recentPageSize));
                    if (recentPage > totalPages) recentPage = totalPages;
                    const start = (recentPage - 1) * recentPageSize;
                    const items = recentAll.slice(start, start + recentPageSize);
                    if (total === 0) {
                        recentWrap.textContent = 'No entries yet.';
                        if (recentControls) recentControls.style.display = 'none';
                        return;
                    }
                    const list = document.createElement('div');
                    items.forEach(e => {
                        const item = document.createElement('div');
                        item.style.marginBottom = '10px';
                        const a = document.createElement('a');
                        a.className = 'link';
                        a.href = `${basePath()}/${encodeURIComponent(user.username)}/${toDisplayDate(e.date)}`;
                        const pval = normalizePrivacyValue(e.privacy, e.isPrivate);
                        const icon = privacyIcon(pval);
                        a.textContent = `${icon ? (icon + ' ') : ''}${toDisplayDate(e.date)} â€” ${e.title || 'Untitled'}`;
                        a.target = '_blank'; a.rel = 'noopener';
                        const preview = document.createElement('div');
                        preview.className = 'helper';
                        const text = String(e.content || '').replace(/\s+/g, ' ').trim();
                        const snippet = text.length > 160 ? text.slice(0, 160) + 'â€¦' : text;
                        preview.textContent = snippet || 'â€”';
                        item.appendChild(a);
                        item.appendChild(preview);
                        list.appendChild(item);
                    });
                    recentWrap.innerHTML = '';
                    recentWrap.appendChild(list);
                    if (recentControls) recentControls.style.display = '';
                    if (recentPageInput) recentPageInput.value = String(recentPage);
                    if (recentPageTotal) recentPageTotal.textContent = '/ ' + String(totalPages);
                    if (recentPrev) recentPrev.disabled = recentPage <= 1;
                    if (recentNext) recentNext.disabled = recentPage >= totalPages;
                }

                if (recentPrev) recentPrev.addEventListener('click', () => { if (recentPage > 1) { recentPage--; renderRecent(); } });
                if (recentNext) recentNext.addEventListener('click', () => { const totalPages = Math.max(1, Math.ceil(recentAll.length / recentPageSize)); if (recentPage < totalPages) { recentPage++; renderRecent(); } });
                if (recentPageInput) recentPageInput.addEventListener('change', () => {
                    let v = parseInt(recentPageInput.value, 10);
                    if (isNaN(v) || v < 1) v = 1;
                    const totalPages = Math.max(1, Math.ceil(recentAll.length / recentPageSize));
                    if (v > totalPages) v = totalPages;
                    recentPage = v;
                    renderRecent();
                });

                async function loadRecent() {
                    try {
                        // Ensure user data is loaded first
                        await ensureUserDataLoaded();
                        
                        // Use cached data for instant response
                        if (clientCache.userLoadedAll && Array.isArray(clientCache.userEntries)) {
                            recentAll = clientCache.userEntries.slice();
                            recentPage = 1;
                            renderRecent();
                            return;
                        }

                        // This should rarely happen now since ensureUserDataLoaded handles the fetch
                        recentWrap.textContent = 'No entries found';
                    } catch (e) { 
                        const wrap = node.querySelector('#recent-list'); 
                        wrap.textContent = e.message; 
                    }
                }

                let currentLoadSeq = 0;
                
                // Smart entry detection function
                function detectNewEntryIntent() {
                    const title = titleInput.value.trim();
                    const content = contentInput.value.trim();
                    
                    // Check if user has started typing something meaningful
                    if (title.length > 0 || content.length > 0) {
                        // If there's content but no existing entry, suggest new entry
                        if (!currentHasEntry) {
                            return 'new_entry';
                        }
                        // If there's content and existing entry, check if it's different
                        if (currentHasEntry && lastSavedSnapshot) {
                            const titleChanged = title !== (lastSavedSnapshot.title || '');
                            const contentChanged = content !== (lastSavedSnapshot.content || '');
                            if (titleChanged || contentChanged) {
                                return 'update_entry';
                            }
                        }
                    }
                    
                    // Check for common "new entry" indicators in title
                    const newEntryKeywords = ['new', 'today', 'entry', 'diary', 'note', 'thought'];
                    const titleLower = title.toLowerCase();
                    if (newEntryKeywords.some(keyword => titleLower.includes(keyword))) {
                        return 'new_entry';
                    }
                    
                    return 'no_change';
                }

                async function load(force) {
                    clearMsg();
                    try {
                        const d = dateInput.value || today();
                        const seq = ++currentLoadSeq;
                        
                        // Clear fields immediately on date switch to avoid showing stale content
                        titleInput.value = '';
                        contentInput.value = '';
                        privacySelect.value = 'public';
                        updateTitleIconFromPrivacy();
                        currentHasEntry = false;
                        currentEntryId = null;
                        if (entrySelect) entrySelect.innerHTML = '';
                        
                        // Ensure user data is loaded first
                        await ensureUserDataLoaded();
                        
                        // Use cached data for instant response
                        let entries = [];
                        const hasPreloadedData = clientCache.userLoadedAll && clientCache.userEntriesByDate && clientCache.userEntriesByDate[d];
                        const isKnownEmpty = !force && clientCache.userEmptyDates && clientCache.userEmptyDates.has(d);
                        
                        if (hasPreloadedData) {
                            // Use preloaded data - instant response
                            entries = clientCache.userEntriesByDate[d];
                        } else if (isKnownEmpty) {
                            // Known empty date from cache
                            titleInput.value = '';
                            contentInput.value = '';
                            privacySelect.value = 'public';
                            updateTitleIconFromPrivacy();
                            currentHasEntry = false;
                            lastSavedSnapshot = { title: '', content: '', privacy: 'public', date: d };
                            setMsg('No entry for ' + toDisplayDate(d), false, true);
                            return;
                        } else {
                            // This should rarely happen now since ensureUserDataLoaded handles the fetch
                            entries = [];
                        }
                        
                        // Populate selector
                        if (entrySelect) {
                            const makeOpt = (text, value) => { const o = document.createElement('option'); o.textContent = text; o.value = value || ''; return o; };
                            entrySelect.appendChild(makeOpt('(New entry)', ''));
                            for (const e of entries) {
                                const pval = normalizePrivacyValue(e.privacy, e.isPrivate);
                                const icon = privacyIcon(pval);
                                const label = `${icon ? (icon + ' ') : ''}${e.title || 'Untitled'}`;
                                const o = makeOpt(label, e.entryId);
                                entrySelect.appendChild(o);
                            }
                            entrySelect.value = entries.length ? entries[0].entryId : '';
                        }
                        
                        let ok = false;
                        if (entries.length) {
                            const e0 = entries[0];
                            currentEntryId = e0.entryId;
                            titleInput.value = e0.title || '';
                            contentInput.value = e0.content || '';
                            setPrivacyValueSafe(e0.privacy, e0.isPrivate);
                            ok = true; currentHasEntry = true;
                        }
                        
                        if (seq !== currentLoadSeq) return; // ignore stale response
                        lastSavedSnapshot = { title: titleInput.value, content: contentInput.value, privacy: privacySelect.value, date: d };
                        
                        if (ok) {
                            setMsg('Loaded entry for ' + toDisplayDate(d), true, true);
                            if (clientCache.userEmptyDates) clientCache.userEmptyDates.delete(d);
                        } else {
                            titleInput.value = '';
                            contentInput.value = '';
                            privacySelect.value = 'public';
                            if (clientCache.userEmptyDates) clientCache.userEmptyDates.add(d);
                            setMsg('No entry for ' + toDisplayDate(d), false, true);
                        }
                        updateTitleIconFromPrivacy();
                        applyEditMode();
                        updateEntryStatus();
                    } catch (e) { setMsg(e.message, false); }
                }

                async function save(showBusy = true) {
                    clearMsg();
                    
                    // Smart detection: check if user really wants to create new entry
                    const intent = detectNewEntryIntent();
                    if (intent === 'no_change') {
                        setMsg('No changes to save', false);
                        return;
                    }
                    
                    const payload = {
                        action: 'saveDiaryEntry',
                        userId: user.id,
                        date: dateInput.value || today(),
                        title: titleInput.value,
                        content: contentInput.value,
                        privacy: privacySelect.value
                    };
                    if (showBusy) showOverlay('Savingâ€¦', 'Please wait');
                    try {
                        const res = await apiPost(payload);
                        if (res.success) {
                            setMsg('Saved.', true);
                            // update client cache using centralized function
                            const entry = { entryId: res.entryId, date: payload.date, title: payload.title, content: payload.content, privacy: payload.privacy };
                            updateCacheAfterEntryOperation('save', entry);
                            currentHasEntry = true;
                            currentEntryId = res.entryId;
                            if (entrySelect) {
                                const o = document.createElement('option');
                                o.value = res.entryId; o.textContent = (titleInput.value || 'Untitled');
                                entrySelect.insertBefore(o, entrySelect.children[1] || null);
                                entrySelect.value = res.entryId;
                            }
                            updateTitleIconFromPrivacy();
                            // re-render dependents
                            renderCalendar();
                            loadRecent();
                        }
                        else { setMsg(res.error || res.message || 'Save failed', false); }
                    } catch (e) { setMsg(e.message, false); }
                    finally { if (showBusy) hideOverlay(); }
                }

                async function update(showBusy = true) {
                    clearMsg();
                    
                    // Smart detection: check if user really wants to update entry
                    const intent = detectNewEntryIntent();
                    if (intent === 'no_change') {
                        setMsg('No changes to update', false);
                        return;
                    }
                    
                    const payload = currentEntryId ? {
                        action: 'updateDiaryEntryById',
                        entryId: currentEntryId,
                        title: titleInput.value,
                        content: contentInput.value,
                        privacy: privacySelect.value
                    } : {
                        action: 'updateDiaryEntry',
                        userId: user.id,
                        date: dateInput.value || today(),
                        title: titleInput.value,
                        content: contentInput.value,
                        privacy: privacySelect.value
                    };
                    if (showBusy) showOverlay('Updatingâ€¦', 'Please wait');
                    try {
                        const res = await apiPost(payload);
                        if (res.success) {
                            setMsg('Updated.', true);
                            // update client cache using centralized function
                            const entry = { 
                                entryId: currentEntryId, 
                                date: payload.date, 
                                title: titleInput.value, 
                                content: contentInput.value, 
                                privacy: privacySelect.value 
                            };
                            updateCacheAfterEntryOperation('update', entry);
                            updateTitleIconFromPrivacy();
                            renderCalendar();
                            loadRecent();
                        }
                        else { setMsg(res.error || res.message || 'Update failed', false); }
                    } catch (e) { setMsg(e.message, false); }
                    finally { if (showBusy) hideOverlay(); }
                }

                async function remove() {
                    if (!confirm('Delete this entry?')) return;
                    clearMsg();
                    showOverlay('Deletingâ€¦', 'Please wait');
                    try {
                        const res = await apiPost(currentEntryId ? { action: 'deleteDiaryEntryById', entryId: currentEntryId } : { action: 'deleteDiaryEntry', userId: user.id, date: dateInput.value || today() });
                        if (res.success) {
                            titleInput.value = ''; contentInput.value = '';
                            privacySelect.value = 'public';
                            updateTitleIconFromPrivacy();
                            setMsg('Deleted.', true);
                            // update client cache using centralized function
                            const entry = { entryId: currentEntryId, date: dateInput.value || today() };
                            updateCacheAfterEntryOperation('delete', entry);
                            currentHasEntry = false;
                            currentEntryId = null;
                            if (entrySelect) {
                                const opt = Array.from(entrySelect.options).find(o => o.value === (res.entryId || '') || o.value === (currentEntryId || ''));
                                if (opt) opt.remove();
                                entrySelect.value = '';
                            }
                            renderCalendar();
                            loadRecent();
                        }
                        else { setMsg(res.error || 'Delete failed', false); }
                    } catch (e) { setMsg(e.message, false); }
                    finally { hideOverlay(); }
                }

                // Add real-time entry detection feedback
                function updateEntryStatus() {
                    const intent = detectNewEntryIntent();
                    const statusEl = node.querySelector('#entry-status');
                    if (statusEl) {
                        switch (intent) {
                            case 'new_entry':
                                statusEl.textContent = 'Ready to create new entry';
                                statusEl.className = 'entry-status new-entry';
                                statusEl.style.display = 'block';
                                break;
                            case 'update_entry':
                                statusEl.textContent = 'Ready to update existing entry';
                                statusEl.className = 'entry-status update-entry';
                                statusEl.style.display = 'block';
                                break;
                            case 'no_change':
                                statusEl.textContent = 'No changes detected';
                                statusEl.className = 'entry-status no-change';
                                statusEl.style.display = 'none';
                                break;
                        }
                    }
                }

                // Add input event listeners for real-time feedback
                titleInput.addEventListener('input', updateEntryStatus);
                contentInput.addEventListener('input', updateEntryStatus);

                node.querySelector('#btn-save').addEventListener('click', save);
                node.querySelector('#btn-update').addEventListener('click', update);
                node.querySelector('#btn-delete').addEventListener('click', remove);
                if (entrySelect) entrySelect.addEventListener('change', () => {
                    const id = entrySelect.value;
                    if (!id) { currentEntryId = null; titleInput.value = ''; contentInput.value = ''; privacySelect.value = 'public'; updateTitleIconFromPrivacy(); applyEditMode(); updateEntryStatus(); return; }
                    const d = dateInput.value || today();
                    const list = clientCache.userEntriesByDate[d] || [];
                    const e = list.find(x => x.entryId === id) || (clientCache.userEntries || []).find(x => x.entryId === id);
                    if (e) {
                        currentEntryId = e.entryId;
                        titleInput.value = e.title || '';
                        contentInput.value = e.content || '';
                        setPrivacyValueSafe(e.privacy, e.isPrivate);
                        applyEditMode();
                        updateEntryStatus();
                    }
                });
                if (btnNewEntry) btnNewEntry.addEventListener('click', () => { entrySelect.value = ''; entrySelect.dispatchEvent(new Event('change')); });
                dateInput.addEventListener('change', async () => { setPermalink(); await load(false); updateTitleIconFromPrivacy(); });
                node.querySelector('#btn-prev-day').addEventListener('click', async () => { dateInput.value = addDaysIso(dateInput.value || today(), -1); setPermalink(); await load(false); updateTitleIconFromPrivacy(); });
                node.querySelector('#btn-next-day').addEventListener('click', async () => { dateInput.value = addDaysIso(dateInput.value || today(), 1); setPermalink(); await load(false); updateTitleIconFromPrivacy(); });
                btnRefresh.addEventListener('click', () => { load(true); });

                // Page unload protection - save before leaving
                window.addEventListener('beforeunload', (e) => {
                    if (editMode && isDirty()) {
                        e.preventDefault();
                        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                        // Try to save synchronously (this might not work in all browsers)
                        tryAutoSave(true, false);
                        return e.returnValue;
                    }
                });

                // Prefetch all user entries first, then load today's entry
                setMsg('Loading all entriesâ€¦', true, true);
                
                (async function prefetchAll() {
                    try {
                        showOverlay('Loading all dataâ€¦', 'Please wait');
                        
                        // Use centralized data loading function
                        const success = await ensureUserDataLoaded(true); // Force refresh
                        
                        if (success) {
                            // Now load today's entry using preloaded data (instant)
                            await load(false);
                            applyEditMode();
                            
                            // Refresh calendar and recent using preloaded data (instant)
                            renderCalendar();
                            loadRecent();
                            
                            setMsg('All data loaded - instant switching enabled', true, true);
                            setTimeout(() => clearMsg(), 2000);
                        } else { 
                            // Fallback if prefetch fails
                            await load(false);
                            applyEditMode();
                            setMsg('Limited data loaded - some features may be slower', false, true);
                        }
                    } catch (e) { 
                        // Fallback if prefetch fails
                        await load(false);
                        applyEditMode();
                        setMsg('Failed to preload data - using on-demand loading', false, true);
                    } finally {
                        hideOverlay();
                    }
                })();
                return node;
            }

            function PublicEntry(username, date) {
                const node = el(`
      <div class="card">
        <h3>Public diary</h3>
        <div class="helper">${username} Â· ${toDisplayDate(date)}</div>
        <div class="spacer"></div>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="pub-detail-prev" class="ghost">Prev day</button>
          <button id="pub-detail-next" class="ghost">Next day</button>
          <button id="pub-detail-refresh" class="ghost">Refresh</button>
          <button id="pub-detail-back" class="ghost">Back to calendar</button>
        </div>
        <div class="spacer"></div>
        <div id="pub-msg" class="notice" style="display:none"></div>
        <div id="pub-title" style="font-weight:600;font-size:16px;margin-bottom:6px"></div>
        <pre id="pub-content" style="white-space:pre-wrap;background:#0c121a;border:1px solid var(--border);padding:12px;border-radius:10px"></pre>
      </div>
    `);

                const msg = node.querySelector('#pub-msg');
                function setMsg(text, ok, quiet) { try { if (!quiet) toast(text, ok); } catch (e) {} msg.textContent = ''; msg.style.display = 'none'; }
                let currentLoadSeq = 0;

                async function renderFromCacheOrFetch(force) {
                    const cached = clientCache.publicByUser.get(username);
                    if (cached && cached.emptyDates instanceof Set && cached.emptyDates.has(date)) {
                        node.querySelector('#pub-title').textContent = '';
                        node.querySelector('#pub-content').textContent = '';
                        setMsg('Not found or private', false);
                        return true;
                    }
                    if (cached && cached.byDate && cached.byDate[date] && cached.byDate[date].length) {
                        const e = cached.byDate[date][0];
                        const pval = String(e.privacy || (e.isPrivate === true || e.isPrivate === 'true' ? 'private' : 'public')).toLowerCase();
                        const icon = privacyIcon(pval);
                        node.querySelector('#pub-title').textContent = (icon ? (icon + ' ') : '') + (e.title || '');
                        node.querySelector('#pub-content').textContent = e.content || '';
                        setMsg('Public entry', true);
                        return true;
                    }
                    return false;
                }

                async function loadPublic(force) {
                    const seq = ++currentLoadSeq;
                    setMsg('Loadingâ€¦', true, true);
                    try {
                        const servedFromCache = await renderFromCacheOrFetch(force);
                        if (!servedFromCache) {
                            const res = await apiGet({ action: 'getDiaryEntry', username, date, viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                            if (seq !== currentLoadSeq) return; // ignore stale
                            if (res.success && res.entry) {
                                const pval = String(res.entry.privacy || (res.entry.isPrivate === true || res.entry.isPrivate === 'true' ? 'private' : 'public')).toLowerCase();
                                const icon = privacyIcon(pval);
                                node.querySelector('#pub-title').textContent = (icon ? (icon + ' ') : '') + (res.entry.title || '');
                                node.querySelector('#pub-content').textContent = res.entry.content || '';
                                setMsg('Public entry', true, true);
                            } else {
                                const needLogin = /not authorized|private/i.test(String(res.error || ''));
                                const link = basePath() + '/';
                                const ask = needLogin ? ' Please login to see friend-only posts.' : '';
                                setMsg((res.error || 'Not found or private') + ask, false, true);
                                if (needLogin && !auth.user) {
                                    const hint = document.createElement('div');
                                    hint.className = 'helper';
                                    hint.style.marginTop = '8px';
                                    const a = document.createElement('a');
                                    a.href = link;
                                    a.className = 'link';
                                    a.textContent = 'Go to Home/Login';
                                    hint.appendChild(a);
                                    msg.appendChild(hint);
                                }
                                const existing = clientCache.publicByUser.get(username) || { entries: [], byDate: {}, emptyDates: new Set() };
                                if (!(existing.emptyDates instanceof Set)) existing.emptyDates = new Set();
                                existing.emptyDates.add(date);
                                clientCache.publicByUser.set(username, existing);
                            }
                        }
                        hideOverlay();
                        if (!clientCache.publicByUser.has(username)) clientCache.publicByUser.set(username, { entries: [], byDate: {}, emptyDates: new Set() });
                        (async function prefetchAllPublic() {
                            try {
                                const monthStr = date.slice(0, 7);
                                const month = await apiGet({ action: 'getPublicDiaryEntries', username, month: monthStr, maxContent: '220', viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                                const storeExisting = clientCache.publicByUser.get(username) || { entries: [], byDate: {}, emptyDates: new Set() };
                                if (!(storeExisting.emptyDates instanceof Set)) storeExisting.emptyDates = new Set();
                                if (month.success && Array.isArray(month.entries)) {
                                    for (const e of month.entries) { const list = storeExisting.byDate[e.date] || (storeExisting.byDate[e.date] = []); if (!list.find(x => x.date === e.date && x.title === e.title)) list.push(e); }
                                    storeExisting.entries = storeExisting.entries.concat(month.entries);
                                    clientCache.publicByUser.set(username, storeExisting);
                                }
                                const all = await apiGet({ action: 'getPublicDiaryEntries', username, limit: '500', viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                                if (all.success && Array.isArray(all.entries)) {
                                    const store = { entries: all.entries, byDate: {}, emptyDates: storeExisting.emptyDates };
                                    for (const e of all.entries) { const list = store.byDate[e.date] || (store.byDate[e.date] = []); list.push(e); }
                                    clientCache.publicByUser.set(username, store);
                                    await renderFromCacheOrFetch(false);
                                }
                            } catch (e) { }
                        })();
                    } catch (e) { setMsg(e.message, false); hideOverlay(); }
                }

                loadPublic(false);

                // Prev/Next day navigation
                node.querySelector('#pub-detail-prev').addEventListener('click', () => {
                    const prev = addDaysIso(date, -1);
                    history.pushState({}, '', basePath() + '/' + encodeURIComponent(username) + '/' + toDisplayDate(prev));
                    render();
                });
                node.querySelector('#pub-detail-next').addEventListener('click', () => {
                    const next = addDaysIso(date, 1);
                    history.pushState({}, '', basePath() + '/' + encodeURIComponent(username) + '/' + toDisplayDate(next));
                    render();
                });
                node.querySelector('#pub-detail-refresh').addEventListener('click', () => { loadPublic(true); });
                node.querySelector('#pub-detail-back').addEventListener('click', () => { history.pushState({}, '', basePath() + '/' + encodeURIComponent(username)); render(); });

                return node;
            }

            function PublicList() {
                const node = el(`
      <div class="card">
        <h3>Latest public entries</h3>
        <div style="display:flex;gap:8px;flex-wrap:wrap;margin-bottom:8px">
          <input id="pub-search" placeholder="Search title, username or date (DD-MM-YYYY)" style="flex:1 1 260px" />
          <select id="pub-filter">
            <option value="all">All</option>
            <option value="title">Title</option>
            <option value="username">Username</option>
            <option value="date">Date</option>
            <option value="content">Content</option>
          </select>
          <button id="pub-apply" class="ghost">Search</button>
        </div>
        <div id="pub-pager" class="pager" style="display:none">
          <button id="pub-page-prev" class="ghost" title="Previous page">â—€</button>
          <span class="helper">Page</span>
          <input id="pub-page-input" type="number" min="1" value="1" />
          <span id="pub-page-total" class="helper">/ 1</span>
          <button id="pub-page-next" class="ghost" title="Next page">â–¶</button>
        </div>
        <div id="pub-list" class="helper">Loadingâ€¦</div>
      </div>
    `);

                const listWrap = node.querySelector('#pub-list');
                const searchInput = node.querySelector('#pub-search');
                const filterSel = node.querySelector('#pub-filter');
                const applyBtn = node.querySelector('#pub-apply');
                const pager = node.querySelector('#pub-pager');
                const prevBtn = node.querySelector('#pub-page-prev');
                const nextBtn = node.querySelector('#pub-page-next');
                const pageInput = node.querySelector('#pub-page-input');
                const pageTotal = node.querySelector('#pub-page-total');
                const pageSize = 10;
                let all = [];
                let filtered = [];
                let page = 1;

                function escapeRegExp(s){ return s.replace(/[.*+?^${}()|[\]\\]/g,'\\$&'); }
                function highlight(text, q){
                    if (!q) return text;
                    try {
                        const re = new RegExp(escapeRegExp(q), 'ig');
                        return String(text).replace(re, m => `<span class="highlight">${m}</span>`);
                    } catch { return text; }
                }
                function normalizeDateQuery(val) {
                    if (!val) return '';
                    const iso = toIsoDate(val);
                    return iso;
                }
                function applyFilters() {
                    const qv = (searchInput.value || '').trim();
                    const mode = filterSel.value;
                    if (!qv) { filtered = all.slice(); page = 1; render(); return; }
                    const qLower = qv.toLowerCase();
                    const isoMaybe = normalizeDateQuery(qv);
                    filtered = all.filter(e => {
                        const title = String(e.title || '');
                        const content = String(e.content || '');
                        const username = String(e.username || '');
                        const date = String(e.date || '');
                        if (mode === 'title') return title.toLowerCase().includes(qLower);
                        if (mode === 'username') return username.toLowerCase().includes(qLower);
                        if (mode === 'content') return content.toLowerCase().includes(qLower);
                        if (mode === 'date') return date === isoMaybe || toDisplayDate(date) === qv;
                        return (
                            title.toLowerCase().includes(qLower) ||
                            username.toLowerCase().includes(qLower) ||
                            content.toLowerCase().includes(qLower) ||
                            date === isoMaybe || toDisplayDate(date) === qv
                        );
                    });
                    page = 1;
                    render();
                }
                function render(){
                    const data = filtered.length ? filtered : all;
                    if (!Array.isArray(data) || data.length === 0) {
                        listWrap.textContent = 'No public entries yet.';
                        if (pager) pager.style.display = 'none';
                        return;
                    }
                    const total = data.length;
                    const totalPages = Math.max(1, Math.ceil(total / pageSize));
                    if (page > totalPages) page = totalPages;
                    const start = (page - 1) * pageSize;
                    const items = data.slice(start, start + pageSize);
                    const list = document.createElement('div');
                    items.forEach(e => {
                        const item = document.createElement('div');
                        item.style.marginBottom = '10px';
                        item.style.border = '1px solid var(--border)';
                        item.style.borderRadius = '10px';
                        item.style.padding = '10px';
                        item.style.background = 'var(--input)';
                        const a = document.createElement('a');
                        a.className = 'link';
                        a.href = `${basePath()}/${encodeURIComponent(e.username)}/${toDisplayDate(e.date)}`;
                        const title = `${toDisplayDate(e.date)} â€“ ${e.username}: ${e.title || 'Untitled'}`;
                        const qv = (searchInput.value || '').trim();
                        if (qv) {
                            a.innerHTML = highlight(title, qv);
                        } else {
                            a.textContent = title;
                        }
                        a.target = '_blank'; a.rel = 'noopener';
                        const preview = document.createElement('div');
                        preview.className = 'helper';
                        preview.style.marginTop = '6px';
                        const text = String(e.content || '').replace(/\s+/g, ' ').trim();
                        const snippet = text.length > 160 ? text.slice(0, 160) + 'â€¦' : text;
                        if ((searchInput.value || '').trim()) {
                            preview.innerHTML = highlight(snippet, (searchInput.value || '').trim());
                        } else {
                            preview.textContent = snippet || 'â€”';
                        }
                        item.appendChild(a);
                        item.appendChild(preview);
                        list.appendChild(item);
                    });
                    listWrap.innerHTML = '';
                    listWrap.appendChild(list);
                    if (pager) pager.style.display = '';
                    if (pageInput) pageInput.value = String(page);
                    if (pageTotal) pageTotal.textContent = '/ ' + String(totalPages);
                    if (prevBtn) prevBtn.disabled = page <= 1;
                    if (nextBtn) nextBtn.disabled = page >= totalPages;
                }
                if (applyBtn) applyBtn.addEventListener('click', applyFilters);
                if (searchInput) searchInput.addEventListener('keypress', (e) => { if (e.key === 'Enter') applyFilters(); });
                if (prevBtn) prevBtn.addEventListener('click', () => { if (page > 1) { page--; render(); } });
                if (nextBtn) nextBtn.addEventListener('click', () => { const data = filtered.length ? filtered : all; const totalPages = Math.max(1, Math.ceil(data.length / pageSize)); if (page < totalPages) { page++; render(); } });
                if (pageInput) pageInput.addEventListener('change', () => { let v = parseInt(pageInput.value, 10); if (isNaN(v) || v < 1) v = 1; const data = filtered.length ? filtered : all; const totalPages = Math.max(1, Math.ceil(data.length / pageSize)); if (v > totalPages) v = totalPages; page = v; render(); });

                (async function () {
                    try {
                        const res = await apiGet({ action: 'getPublicDiaryEntries', limit: '50', maxContent: '220', viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                        if (!res.success) { listWrap.textContent = res.error || 'Failed to load'; return; }
                        all = Array.isArray(res.entries) ? res.entries.slice(0, 500) : [];
                        filtered = all.slice();
                        page = 1;
                        render();
                    } catch (e) { node.querySelector('#pub-list').textContent = e.message; }
                })();

                return node;
            }

            function PublicUser(username) {
                const node = el(`
      <div class="card">
        <h3>Public calendar</h3>
        <div class="helper">${username}</div>
        <div class="spacer"></div>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px">
          <button id="cal-prev" class="ghost">Prev</button>
          <div id="cal-label" class="badge"></div>
          <button id="cal-next" class="ghost">Next</button>
        </div>
        <div id="calendar"></div>
        <div class="spacer"></div>
        <div id="month-strip"></div>
      </div>
    `);

                let calYear = new Date().getFullYear();
                let calMonth = new Date().getMonth();
                const calLabel = node.querySelector('#cal-label');
                const calPrev = node.querySelector('#cal-prev');
                const calNext = node.querySelector('#cal-next');
                const calHost = node.querySelector('#calendar');

                let publicEntries = null; // month-first, then all

                calPrev.addEventListener('click', () => { calMonth--; if (calMonth < 0) { calMonth = 11; calYear--; } renderCalendar(); });
                calNext.addEventListener('click', () => { calMonth++; if (calMonth > 11) { calMonth = 0; calYear++; } renderCalendar(); });

                async function ensureEntries() {
                    // If background all-data cache exists, use it
                    const cachedUser = clientCache.publicByUser.get(username);
                    if (cachedUser && Array.isArray(cachedUser.entries) && cachedUser.entries.length) {
                        publicEntries = cachedUser.entries;
                        return publicEntries;
                    }
                    if (publicEntries) return publicEntries;
                    // Quick month fetch for fast first paint
                    try {
                        const monthStr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0');
                        const res = await apiGet({ action: 'getPublicDiaryEntries', username, month: monthStr, maxContent: '160', viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                        publicEntries = (res.success && Array.isArray(res.entries)) ? res.entries : [];
                        try {
                            const existing = clientCache.publicByUser.get(username) || { entries: [], byDate: {}, emptyDates: new Set() };
                            for (const e of publicEntries) {
                                const list = existing.byDate[e.date] || (existing.byDate[e.date] = []);
                                if (!list.find(x => x.date === e.date && x.title === e.title)) list.push(e);
                            }
                            existing.entries = existing.entries.concat(publicEntries);
                            clientCache.publicByUser.set(username, existing);
                        } catch (e) {}
                    } catch (e) { publicEntries = []; }
                    // Background prefetch of all public entries for user
                    (async function prefetchAll() {
                        try {
                            const all = await apiGet({ action: 'getPublicDiaryEntries', username, limit: '500', maxContent: '220', viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                            if (all.success && Array.isArray(all.entries)) {
                                const existingStore = clientCache.publicByUser.get(username) || { entries: [], byDate: {}, emptyDates: new Set() };
                                const store = { entries: all.entries, byDate: {}, emptyDates: (existingStore.emptyDates instanceof Set) ? existingStore.emptyDates : new Set() };
                                for (const e of all.entries) { const list = store.byDate[e.date] || (store.byDate[e.date] = []); list.push(e); }
                                clientCache.publicByUser.set(username, store);
                                publicEntries = all.entries;
                                // re-render current month with full data once ready
                                renderCalendar();
                            }
                        } catch (e) { }
                    })();
                    return publicEntries;
                }

                async function renderCalendar() {
                    const first = new Date(calYear, calMonth, 1);
                    const monthStr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0');
                    calLabel.textContent = first.toLocaleString(undefined, { month: 'long', year: 'numeric' });
                    calHost.innerHTML = '';
                    const loading = document.createElement('div'); loading.className = 'helper'; loading.textContent = 'Loadingâ€¦'; calHost.appendChild(loading);
                    // Hide overlay early so the calendar shell is visible immediately
                    hideOverlay();
                    const grid = document.createElement('div');
                    grid.style.display = 'grid';
                    grid.style.gridTemplateColumns = 'repeat(7,1fr)';
                    grid.style.gap = '8px';
                    const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    weekdays.forEach(d => { const h = document.createElement('div'); h.className = 'helper'; h.textContent = d; grid.appendChild(h); });
                    const startPad = first.getDay();
                    const daysInMonth = new Date(calYear, calMonth + 1, 0).getDate();
                    for (let i = 0; i < startPad; i++) { const pad = document.createElement('div'); grid.appendChild(pad); }

                    const entries = await ensureEntries();
                    const entriesByDate = {};
                    for (const e of entries) {
                        const list = entriesByDate[e.date] || (entriesByDate[e.date] = []);
                        list.push(e);
                    }

                    calHost.innerHTML = '';
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dstr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                        const cell = document.createElement('div');
                        cell.style.border = '1px solid var(--border)';
                        cell.style.borderRadius = '10px';
                        cell.style.padding = '8px';
                        cell.style.minHeight = '72px';
                        cell.style.height = '96px';
                        cell.style.overflow = 'hidden';
                        cell.style.display = 'flex';
                        cell.style.flexDirection = 'column';
                        cell.style.background = 'var(--input)';
                        const head = document.createElement('div'); head.className = 'helper'; head.textContent = day; cell.appendChild(head);
                        const list = entriesByDate[dstr] || [];
                        const count = list.length;
                        if (count > 0) {
                            const a = document.createElement('a'); a.className = 'link truncate'; a.href = `${basePath()}/${encodeURIComponent(username)}/${toDisplayDate(dstr)}`; a.target = '_blank'; a.rel = 'noopener';
                            const first = list[0];
                            a.textContent = (first.title || 'Untitled');
                            a.title = (first.title || 'Untitled');
                            try { cell.title = list.map(e => (e.title || 'Untitled')).join('\n'); } catch (e) {}
                            const p = document.createElement('div'); p.style.marginTop = '6px'; p.appendChild(a); cell.appendChild(p);
                            const badge = document.createElement('span'); badge.className = 'badge'; badge.textContent = String(count);
                            badge.style.float = 'right';
                            head.appendChild(badge);
                        } else {
                            const p = document.createElement('div'); p.className = 'helper'; p.style.marginTop = '6px'; p.textContent = 'â€”'; cell.appendChild(p);
                        }
                        cell.addEventListener('click', () => { history.pushState({}, '', `${basePath()}/${encodeURIComponent(username)}/${toDisplayDate(dstr)}`); render(); });
                        grid.appendChild(cell);
                    }
                    calHost.appendChild(grid);

                    // Month strip (narrow bar showing daily availability)
                    const strip = node.querySelector('#month-strip');
                    strip.innerHTML = '';
                    const stripGrid = document.createElement('div');
                    stripGrid.style.display = 'grid';
                    stripGrid.style.gridTemplateColumns = `repeat(${daysInMonth},1fr)`;
                    stripGrid.style.gap = '2px';
                    stripGrid.style.alignItems = 'stretch';
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dstr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                        const bar = document.createElement('div');
                        const has = (entriesByDate[dstr] || []).length > 0;
                        bar.style.height = '6px';
                        bar.style.borderRadius = '4px';
                        bar.style.background = has ? 'var(--accent)' : 'var(--border)';
                        bar.title = toDisplayDate(dstr);
                        bar.style.cursor = 'pointer';
                        bar.addEventListener('click', () => { history.pushState({}, '', `${basePath()}/${encodeURIComponent(username)}/${toDisplayDate(dstr)}`); render(); });
                        stripGrid.appendChild(bar);
                    }
                    strip.appendChild(stripGrid);

                    // Hide overlay after first calendar paint for public user calendar
                    hideOverlay();
                }

                renderCalendar();
                return node;
            }

            const navLogin = q('#nav-login');
            if (navLogin) {
                navLogin.addEventListener('click', (e) => { e.preventDefault(); openAuthModal('login'); });
            }
            const navUser = q('#nav-user');
            const userMenu = q('#user-menu');
            function toggleUserMenu(show) {
                if (!userMenu) return;
                userMenu.style.display = show ? 'block' : 'none';
                if (show) {
                    const last = storage.get('diary_last_seen');
                    const el = q('#menu-last-online');
                    if (el) {
                        if (last) { el.style.display = ''; el.textContent = 'Last online: ' + last; } else { el.style.display = 'none'; }
                    }
                }
            }
            if (navUser) {
                navUser.addEventListener('click', (e) => { e.preventDefault(); toggleUserMenu(userMenu.style.display === 'none'); });
            }
            document.addEventListener('click', (e) => {
                if (!userMenu) return;
                const target = e.target;
                const within = target === userMenu || userMenu.contains(target) || target === navUser;
                if (!within) toggleUserMenu(false);
            });
            const menuLogout = q('#menu-logout'); if (menuLogout) menuLogout.addEventListener('click', (e) => { e.preventDefault(); auth.user = null; toggleUserMenu(false); render(); });
            const menuFriends = q('#menu-friends'); if (menuFriends) menuFriends.addEventListener('click', (e) => { e.preventDefault(); toggleUserMenu(false); openFriendsModal(); });

            // Friends modal
            function openFriendsModal() {
                const listEl = document.createElement('div');
                listEl.className = 'helper';
                showOverlay('Friends', 'Loadingâ€¦');
                (async () => {
                    try {
                        const res = await apiGet({ action: 'listFriends', ownerId: auth.user && auth.user.id });
                        hideOverlay();
                        const modal = q('#auth-modal');
                        const title = q('#auth-modal-title');
                        const body = q('#auth-modal-body');
                        if (!modal || !title || !body) return;
                        title.textContent = 'Friends';
                        body.innerHTML = '';
                        const host = document.createElement('div');
                        const addWrap = document.createElement('div');
                        addWrap.style.display = 'flex'; addWrap.style.gap = '8px'; addWrap.style.marginBottom = '12px'; addWrap.style.flexWrap = 'wrap';
                        const addInput = document.createElement('input'); addInput.placeholder = 'email, username, or userId'; addInput.style.flex = '1 1 240px'; addInput.id = 'friends-add-input';
                        const addBtn = document.createElement('button'); addBtn.textContent = 'Add'; addBtn.id = 'friends-add-btn';
                        addWrap.appendChild(addInput); addWrap.appendChild(addBtn);
                        host.appendChild(addWrap);
                        if (!res.success || !Array.isArray(res.friends) || res.friends.length === 0) {
                            const empty = document.createElement('div'); empty.className = 'helper'; empty.textContent = 'No friends yet.'; host.appendChild(empty);
                        } else {
                            res.friends.forEach(f => {
                                const row = document.createElement('div');
                                row.style.display = 'flex'; row.style.justifyContent = 'space-between'; row.style.alignItems = 'center'; row.style.marginBottom = '8px';
                                const left = document.createElement('div'); left.className = 'helper';
                                const name = f.friendUsername || f.friendEmail || f.friendUserId || '';
                                const lastSeen = f.lastSeen ? new Date(f.lastSeen) : null;
                                const isOnline = lastSeen && (Date.now() - new Date(lastSeen).getTime()) < 120000; // 2 minutes
                                left.textContent = name + (isOnline ? ' â€¢ online' : (lastSeen ? (' â€¢ last: ' + new Date(lastSeen).toLocaleString()) : ''));
                                const rem = document.createElement('button'); rem.className = 'danger'; rem.textContent = 'Remove';
                                rem.addEventListener('click', async () => {
                                    showOverlay('Removing friendâ€¦', 'Please wait');
                                    try { await apiPost({ action: 'removeFriend', ownerId: auth.user && auth.user.id, friendIdentifier: f.friendUserId || f.friendEmail }); row.remove(); } catch (e) {}
                                    finally { hideOverlay(); }
                                });
                                row.appendChild(left); row.appendChild(rem); host.appendChild(row);
                            });
                        }
                        body.appendChild(host);
                        openAuthModal('login'); // open modal shell
                        const loginForm = q('#auth-login-form'); if (loginForm) loginForm.style.display = 'none';
                        const regForm = q('#auth-register-form'); if (regForm) regForm.style.display = 'none';
                        q('#auth-modal').style.display = 'grid';

                        // Wire add button
                        addBtn.addEventListener('click', async () => {
                            const val = (addInput.value || '').trim(); if (!val) return;
                            showOverlay('Adding friendâ€¦', 'Please wait');
                            try {
                                const r = await apiPost({ action: 'addFriend', ownerId: auth.user && auth.user.id, friendIdentifier: val });
                                if (r.success) { addInput.value = ''; openFriendsModal(); }
                            } catch (e) {}
                            finally { hideOverlay(); }
                        });
                    } catch (e) { hideOverlay(); toast(e.message, false); }
                })();
            }

            // Modal events
            const modalClose = q('#auth-close'); if (modalClose) modalClose.addEventListener('click', closeAuthModal);
            const switchToRegister = q('#switch-to-register'); if (switchToRegister) switchToRegister.addEventListener('click', (e) => { e.preventDefault(); openAuthModal('register'); });
            const switchToLogin = q('#switch-to-login'); if (switchToLogin) switchToLogin.addEventListener('click', (e) => { e.preventDefault(); openAuthModal('login'); });
            // Shared state for OTP flow
            let __otpFlow = { mode: null, email: '', identifier: '', username: '', password: '' };

            const modalBtnLogin = q('#modal-btn-login'); if (modalBtnLogin) modalBtnLogin.addEventListener('click', async () => {
                const identifier = (q('#modal-login-identifier').value || '').trim();
                const password = q('#modal-login-password').value || '';
                const otp = (q('#modal-login-otp').value || '').trim();
                const msg = q('#modal-auth-msg'); if (msg) { msg.textContent = ''; msg.className = 'helper'; }
                
                // Check if OTP section is visible (meaning OTP was already sent)
                const otpSection = q('#login-otp-section');
                const isOtpSectionVisible = otpSection && otpSection.style.display !== 'none';
                
                if (isOtpSectionVisible && otp) {
                    // OTP section is visible and user entered OTP - verify and login
                    showOverlay('Verifying OTPâ€¦', 'Please wait');
                    try {
                        // Get email from identifier (could be email or username)
                        let email = identifier;
                        if (!identifier.includes('@')) {
                            // If it's a username, lookup the email
                            const emailRes = await apiGet({ action: 'getEmailByUsername', username: identifier });
                            if (!emailRes.success) {
                                if (msg) { msg.textContent = emailRes.error || 'Username not found'; msg.className = 'helper error'; }
                                hideOverlay();
                                return;
                            }
                            email = emailRes.email;
                        }
                        
                        console.log('Verifying OTP for login:', { email, otp });
                        const otpRes = await otpApiPost({ action: 'verifyOtp', email, otp });
                        console.log('OTP verification result:', otpRes);
                        if (!otpRes.success) {
                            if (msg) { msg.textContent = otpRes.error || 'Invalid or expired OTP'; msg.className = 'helper error'; }
                            hideOverlay();
                            return;
                        }
                        
                        // OTP verified, now proceed with login
                        const res = await apiPost({ action: 'login', identifier, password });
                        if (res.success) {
                            auth.user = res.user;
                            closeAuthModal();
                            render();
                        } else {
                            if (msg) { msg.textContent = res.error || res.message || 'Login failed'; msg.className = 'helper error'; }
                        }
                    } catch (e) { if (msg) { msg.textContent = e.message; msg.className = 'helper error'; } }
                    finally { hideOverlay(); }
                } else {
                    // Send OTP first and switch to dedicated OTP view
                    showOverlay('Sending OTPâ€¦', 'Please wait');
                    try {
                        let email = identifier;
                        if (!identifier.includes('@')) {
                            const emailRes = await apiGet({ action: 'getEmailByUsername', username: identifier });
                            if (!emailRes.success) {
                                if (msg) { msg.textContent = emailRes.error || 'Username not found'; msg.className = 'helper error'; }
                                hideOverlay();
                                return;
                            }
                            email = emailRes.email;
                        }

                        const otpRes = await otpApiPost({ action: 'sendOtp', email, username: identifier });
                        if (!otpRes.success) {
                            if (msg) { msg.textContent = otpRes.error || 'Failed to send OTP'; msg.className = 'helper error'; }
                            hideOverlay();
                            return;
                        }

                        // Prepare OTP view
                        __otpFlow = { mode: 'login', email, identifier, username: identifier, password };
                        const title = q('#auth-modal-title'); if (title) title.textContent = 'Verify OTP';
                        const loginForm = q('#auth-login-form'); if (loginForm) loginForm.style.display = 'none';
                        const regForm = q('#auth-register-form'); if (regForm) regForm.style.display = 'none';
                        const otpView = q('#otp-verify-view'); if (otpView) otpView.style.display = '';
                        const subtitle = q('#otp-subtitle'); if (subtitle) subtitle.textContent = `We sent a code to â€¢ ${maskEmail(email)}`;
                        const otpMsg = q('#otp-msg'); if (otpMsg) { otpMsg.textContent = 'Enter the 6-digit code from your email.'; otpMsg.className = 'helper'; }
                        const otpInput = q('#otp-input'); if (otpInput) { otpInput.value = ''; otpInput.focus(); }
                    } catch (e) { if (msg) { msg.textContent = e.message; msg.className = 'helper error'; } }
                    finally { hideOverlay(); }
                }
            });
            const modalBtnRegister = q('#modal-btn-register'); if (modalBtnRegister) modalBtnRegister.addEventListener('click', async () => {
                const email = (q('#modal-reg-email').value || '').trim();
                const username = (q('#modal-reg-username').value || '').trim();
                const password = q('#modal-reg-password').value || '';
                const otp = (q('#modal-reg-otp').value || '').trim();
                const msg = q('#modal-auth-msg-reg'); if (msg) { msg.textContent = ''; msg.className = 'helper'; }
                
                // Check if OTP section is visible (meaning OTP was already sent)
                const otpSection = q('#register-otp-section');
                const isOtpSectionVisible = otpSection && otpSection.style.display !== 'none';
                
                if (isOtpSectionVisible && otp) {
                    // OTP section is visible and user entered OTP - verify and register
                    showOverlay('Verifying OTPâ€¦', 'Please wait');
                    try {
                        console.log('Verifying OTP for registration:', { email, otp });
                        const otpRes = await otpApiPost({ action: 'verifyOtp', email, otp });
                        console.log('OTP verification result:', otpRes);
                        if (!otpRes.success) {
                            if (msg) { msg.textContent = otpRes.error || 'Invalid or expired OTP'; msg.className = 'helper error'; }
                            hideOverlay();
                            return;
                        }
                        
                        // OTP verified, now proceed with registration
                        const res = await apiPost({ action: 'register', email, username, password });
                        if (res.success) {
                            // Auto-login after successful registration (no extra OTP required)
                            try {
                                const loginRes = await apiPost({ action: 'login', identifier: email || username, password });
                                if (loginRes.success) {
                                    auth.user = loginRes.user;
                                    closeAuthModal();
                                    render();
                                } else {
                                    if (msg) { msg.textContent = (loginRes.error || 'Registered, but auto-login failed. Please login.'); msg.className = 'helper error'; }
                                }
                            } catch (e) {
                                if (msg) { msg.textContent = 'Registered, but auto-login failed: ' + e.message; msg.className = 'helper error'; }
                            }
                        } else {
                            if (msg) { msg.textContent = res.error || res.message || 'Registration failed'; msg.className = 'helper error'; }
                        }
                    } catch (e) { if (msg) { msg.textContent = e.message; msg.className = 'helper error'; } }
                    finally { hideOverlay(); }
                } else {
                    // Send OTP first and switch to dedicated OTP view
                    showOverlay('Sending OTPâ€¦', 'Please wait');
                    try {
                        if (username.length < 5 || username.length > 20) { 
                            if (msg) { msg.textContent = 'Username must be 5-20 characters'; msg.className = 'helper error'; } 
                            hideOverlay(); 
                            return; 
                        }

                        const otpRes = await otpApiPost({ action: 'sendOtp', email, username });
                        if (!otpRes.success) {
                            if (msg) { msg.textContent = otpRes.error || 'Failed to send OTP'; msg.className = 'helper error'; }
                            hideOverlay();
                            return;
                        }

                        // Prepare OTP view
                        __otpFlow = { mode: 'register', email, identifier: email, username, password };
                        const title = q('#auth-modal-title'); if (title) title.textContent = 'Verify OTP';
                        const loginForm = q('#auth-login-form'); if (loginForm) loginForm.style.display = 'none';
                        const regForm = q('#auth-register-form'); if (regForm) regForm.style.display = 'none';
                        const otpView = q('#otp-verify-view'); if (otpView) otpView.style.display = '';
                        const subtitle = q('#otp-subtitle'); if (subtitle) subtitle.textContent = `We sent a code to ${maskEmail(email)} â€¢ ${email}  Change email`;
                        const otpMsg = q('#otp-msg'); if (otpMsg) { otpMsg.textContent = 'Enter the 6-digit code from your email.'; otpMsg.className = 'helper'; }
                        const otpInput = q('#otp-input'); if (otpInput) { otpInput.value = ''; otpInput.focus(); }
                    } catch (e) { if (msg) { msg.textContent = e.message; msg.className = 'helper error'; } }
                    finally { hideOverlay(); }
                }
            });

            // OTP view actions
            function maskEmail(email) {
                const at = email.indexOf('@');
                if (at <= 1) return email;
                const name = email.slice(0, at);
                const domain = email.slice(at);
                const masked = name[0] + '*'.repeat(Math.max(1, name.length - 2)) + name.slice(-1);
                return masked + domain;
            }
            const otpVerifyBtn = q('#otp-verify-btn'); if (otpVerifyBtn) otpVerifyBtn.addEventListener('click', async () => {
                const otp = (q('#otp-input').value || '').trim();
                const msg = q('#otp-msg'); if (msg) { msg.textContent = ''; msg.className = 'helper'; }
                if (!__otpFlow.email || !__otpFlow.mode) { if (msg) { msg.textContent = 'Session expired. Please try again.'; msg.className = 'helper error'; } return; }
                if (!otp || otp.length !== 6) { if (msg) { msg.textContent = 'Enter the 6-digit code.'; msg.className = 'helper error'; } return; }
                showOverlay('Verifying OTPâ€¦', 'Please wait');
                try {
                    const otpRes = await otpApiPost({ action: 'verifyOtp', email: __otpFlow.email, otp });
                    if (!otpRes.success) { if (msg) { msg.textContent = otpRes.error || 'Invalid or expired OTP'; msg.className = 'helper error'; } hideOverlay(); return; }
                    if (__otpFlow.mode === 'login') {
                        const res = await apiPost({ action: 'login', identifier: __otpFlow.identifier, password: __otpFlow.password });
                        if (res.success) { auth.user = res.user; closeAuthModal(); render(); }
                        else { if (msg) { msg.textContent = res.error || res.message || 'Login failed'; msg.className = 'helper error'; } }
                    } else if (__otpFlow.mode === 'register') {
                        const res = await apiPost({ action: 'register', email: __otpFlow.email, username: __otpFlow.username, password: __otpFlow.password });
                        if (res.success) {
                            try {
                                const loginRes = await apiPost({ action: 'login', identifier: __otpFlow.email || __otpFlow.username, password: __otpFlow.password });
                                if (loginRes.success) { auth.user = loginRes.user; closeAuthModal(); render(); }
                                else { if (msg) { msg.textContent = (loginRes.error || 'Registered, but auto-login failed. Please login.'); msg.className = 'helper error'; } }
                            } catch (e) { if (msg) { msg.textContent = 'Registered, but auto-login failed: ' + e.message; msg.className = 'helper error'; } }
                        } else { if (msg) { msg.textContent = res.error || res.message || 'Registration failed'; msg.className = 'helper error'; } }
                    }
                } catch (e) { if (msg) { msg.textContent = e.message; msg.className = 'helper error'; } }
                finally { hideOverlay(); }
            });

            const otpResendBtn = q('#otp-resend-btn'); if (otpResendBtn) otpResendBtn.addEventListener('click', async () => {
                const msg = q('#otp-msg'); if (msg) { msg.textContent = ''; msg.className = 'helper'; }
                if (!__otpFlow.email || !__otpFlow.username) { if (msg) { msg.textContent = 'Session expired. Please try again.'; msg.className = 'helper error'; } return; }
                showOverlay('Resending OTPâ€¦', 'Please wait');
                try {
                    const res = await otpApiPost({ action: 'sendOtp', email: __otpFlow.email, username: __otpFlow.username });
                    if (res.success) { if (msg) { msg.textContent = 'OTP resent to your email'; msg.className = 'helper success'; } }
                    else { if (msg) { msg.textContent = res.error || res.message || 'Failed to resend OTP'; msg.className = 'helper error'; } }
                } catch (e) { if (msg) { msg.textContent = e.message; msg.className = 'helper error'; } }
                finally { hideOverlay(); }
            });

            const otpChangeEmail = q('#otp-change-email'); if (otpChangeEmail) otpChangeEmail.addEventListener('click', (e) => {
                e.preventDefault();
                // Go back to appropriate form
                const title = q('#auth-modal-title');
                const otpView = q('#otp-verify-view'); if (otpView) otpView.style.display = 'none';
                if (__otpFlow.mode === 'login') {
                    if (title) title.textContent = 'Login';
                    const loginForm = q('#auth-login-form'); if (loginForm) loginForm.style.display = '';
                } else {
                    if (title) title.textContent = 'Register';
                    const regForm = q('#auth-register-form'); if (regForm) regForm.style.display = '';
                }
                __otpFlow = { mode: null, email: '', identifier: '', username: '', password: '' };
            });
            // Resend OTP functionality
            const modalBtnResendOtp = q('#modal-btn-resend-otp'); 
            if (modalBtnResendOtp) modalBtnResendOtp.addEventListener('click', async () => {
                const identifier = (q('#modal-login-identifier').value || '').trim();
                const msg = q('#modal-auth-msg'); 
                if (msg) { msg.textContent = ''; msg.className = 'helper'; }
                showOverlay('Resending OTPâ€¦', 'Please wait');
                try {
                    let email = identifier;
                    if (!identifier.includes('@')) {
                        // If it's a username, lookup the email
                        const emailRes = await apiGet({ action: 'getEmailByUsername', username: identifier });
                        if (!emailRes.success) {
                            if (msg) { msg.textContent = emailRes.error || 'Username not found'; msg.className = 'helper error'; }
                            hideOverlay();
                            return;
                        }
                        email = emailRes.email;
                    }
                    
                    const res = await otpApiPost({ action: 'sendOtp', email, username: identifier });
                    if (res.success) {
                        if (msg) { msg.textContent = 'OTP resent to your email'; msg.className = 'helper success'; }
                    } else {
                        if (msg) { msg.textContent = res.error || res.message || 'Failed to resend OTP'; msg.className = 'helper error'; }
                    }
                } catch (e) { if (msg) { msg.textContent = e.message; msg.className = 'helper error'; } }
                finally { hideOverlay(); }
            });

            const modalBtnResendRegOtp = q('#modal-btn-resend-reg-otp'); 
            if (modalBtnResendRegOtp) modalBtnResendRegOtp.addEventListener('click', async () => {
                const email = (q('#modal-reg-email').value || '').trim();
                const username = (q('#modal-reg-username').value || '').trim();
                const msg = q('#modal-auth-msg-reg'); 
                if (msg) { msg.textContent = ''; msg.className = 'helper'; }
                showOverlay('Resending OTPâ€¦', 'Please wait');
                try {
                    const res = await otpApiPost({ action: 'sendOtp', email, username });
                    if (res.success) {
                        if (msg) { msg.textContent = 'OTP resent to your email'; msg.className = 'helper success'; }
                    } else {
                        if (msg) { msg.textContent = res.error || res.message || 'Failed to resend OTP'; msg.className = 'helper error'; }
                    }
                } catch (e) { if (msg) { msg.textContent = e.message; msg.className = 'helper error'; } }
                finally { hideOverlay(); }
            });

            window.addEventListener('hashchange', render);
            window.addEventListener('popstate', render);

            // Initial render
            render();

            // Presence ping every 60s when logged in
            let pingTimer = null;
            function startPresence() {
                if (pingTimer) clearInterval(pingTimer);
                if (!auth.user) return;
                const send = async () => {
                    try {
                        const res = await apiPost({ action: 'ping', userId: auth.user.id });
                        const now = new Date().toLocaleString();
                        storage.set('diary_last_seen', now, 1);
                    } catch (e) {}
                };
                send();
                pingTimer = setInterval(send, 60000);
            }
            startPresence();
            window.addEventListener('storage', () => { startPresence(); });
        })();
    </script>
</body>

</html>