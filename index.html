<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Diary</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0b0e14;
            --panel: #111620;
            --panel-2: #0f1420;
            --text: #e6edf3;
            --muted: #9aa5b1;
            --accent: #3b82f6;
            --accent-2: #60a5fa;
            --danger: #ef4444;
            --ok: #10b981;
            --border: #1f2937;
            --input: #0c121c
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            background: linear-gradient(180deg, #0b0e14, #0a0f1a 40%, #0b1220);
            color: var(--text)
        }

        .container {
            max-width: 960px;
            margin: 0 auto;
            padding: 24px
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px
        }

        .brand {
            font-weight: 700;
            letter-spacing: .4px
        }

        .nav a {
            color: var(--muted);
            text-decoration: none;
            margin-left: 16px
        }

        .card {
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
            padding: 20px
        }

        .row {
            display: flex;
            gap: 16px;
            flex-wrap: wrap
        }

        .col {
            flex: 1 1 320px
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px
        }

        input,
        textarea,
        select,
        button {
            font: inherit
        }

        input,
        textarea {
            width: 100%;
            padding: 12px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--input);
            color: var(--text)
        }

        textarea {
            min-height: 220px;
            resize: vertical
        }

        button {
            background: var(--accent);
            color: white;
            border: 0;
            border-radius: 10px;
            padding: 10px 14px;
            cursor: pointer
        }

        button.ghost {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text)
        }

        button.danger {
            background: var(--danger)
        }

        button:disabled {
            opacity: .6;
            cursor: not-allowed
        }

        .helper {
            font-size: 12px;
            color: var(--muted)
        }

        .spacer {
            height: 12px
        }

        hr {
            border: 0;
            border-top: 1px solid var(--border);
            margin: 16px 0
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 12px;
            border: 1px solid var(--border);
            background: #0c121a;
            color: var(--muted)
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            background: #0e1420;
            border: 1px solid var(--border);
            border-bottom-color: #111826;
            border-radius: 6px;
            padding: 2px 6px;
            color: #bcd;
        }

        .link {
            color: var(--accent-2);
            text-decoration: none
        }

        .footer {
            margin-top: 28px;
            color: var(--muted);
            font-size: 12px;
            text-align: center
        }

        .notice {
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #0c1320;
            color: #cbd5e1
        }

        .error {
            color: #fecaca
        }

        .success {
            color: #bbf7d0
        }
        .truncate {
            display: block;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis
        }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <div class="brand">Daily Diary</div>
            <div class="nav">
                <a id="nav-home" href="#">Home</a>
                <a id="nav-public" href="#public">Public</a>
                <a id="nav-logout" href="#" style="display:none">Logout</a>
            </div>
        </div>

        <div id="route-view"></div>

        <div class="footer">Make By PEPSEALSEA ©2025
        </div>
    </div>

    <script>
        (function () {
            const API_URL = 'https://script.google.com/macros/s/AKfycbxR7BQFNg_LHPspcMYXLpdwMQ6Ql6fzr1DVDryXCYdW4aPJlvb4oXFPx-Tng4ofmQLvmw/exec';
            const storage = {
                set(k, v, days) {
                    const value = typeof v === 'string' ? v : JSON.stringify(v);
                    const expires = days ? "; max-age=" + (days * 24 * 60 * 60) : '';
                    document.cookie = encodeURIComponent(k) + "=" + encodeURIComponent(value) + expires + "; path=/";
                },
                get(k) {
                    const name = encodeURIComponent(k) + "=";
                    const parts = document.cookie.split('; ');
                    for (const p of parts) {
                        if (p.startsWith(name)) {
                            const val = decodeURIComponent(p.substring(name.length));
                            try { return JSON.parse(val); } catch { return val; }
                        }
                    }
                    return null;
                },
                del(k) {
                    document.cookie = encodeURIComponent(k) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
                }
            };

            const auth = {
                get user() { return storage.get('diary_user'); },
                set user(u) { if (u) storage.set('diary_user', u, 30); else storage.del('diary_user'); }
            };

            function q(sel, root = document) { return root.querySelector(sel); }
            function el(html) { const t = document.createElement('template'); t.innerHTML = html.trim(); return t.content.firstChild; }
            const clientCache = {
                userEntries: null, // Array of all entries for logged-in user
                userEntriesByDate: {}, // date -> entries[]
                userLoadedAll: false,
                publicByUser: new Map(), // username -> {entries: [], byDate: {}}
            };
            function fmtDate(d) {
                const x = new Date(d);
                const y = x.getFullYear();
                const m = String(x.getMonth() + 1).padStart(2, '0');
                const day = String(x.getDate()).padStart(2, '0');
                return y + '-' + m + '-' + day; // local date, not UTC
            }
            function today() { return fmtDate(new Date()); }
            function toDisplayDate(iso) {
                // iso: YYYY-MM-DD -> DD-MM-YYYY
                if (!iso || !/^\d{4}-\d{2}-\d{2}$/.test(iso)) return iso || '';
                const [y, m, d] = iso.split('-');
                return d + '-' + m + '-' + y;
            }
            function toIsoDate(maybe) {
                // Accept DD-MM-YYYY or YYYY-MM-DD and normalize to ISO
                if (!maybe) return '';
                if (/^\d{4}-\d{2}-\d{2}$/.test(maybe)) return maybe;
                const m = maybe.match(/^(\d{2})-(\d{2})-(\d{4})$/);
                if (m) return m[3] + '-' + m[2] + '-' + m[1];
                return fmtDate(maybe);
            }
            function addDaysIso(iso, delta) {
                const d = new Date(toIsoDate(iso));
                d.setDate(d.getDate() + delta);
                return fmtDate(d);
            }
            function basePath() {
                const segs = location.pathname.split('/').filter(Boolean);
                return segs.length ? '/' + segs[0] : '';
            }

            async function apiGet(params) {
                if (!API_URL) { throw new Error('API URL not configured'); }
                const qs = new URLSearchParams(params).toString();
                const res = await fetch(API_URL + '?' + qs, { method: 'GET' });
                return res.json();
            }
            async function apiPost(params) {
                if (!API_URL) { throw new Error('API URL not configured'); }
                const form = new URLSearchParams(params);
                const res = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: form.toString() });
                return res.json();
            }

            function show(elm) { elm.style.display = ''; }
            function hide(elm) { elm.style.display = 'none'; }

            function render() {
                const mount = q('#route-view');
                mount.innerHTML = '';

                const qp = new URLSearchParams(window.location.search);
                const pathParam = qp.get('path');
                const rawPath = pathParam || window.location.pathname;
                const trimmed = rawPath.replace(new RegExp('^' + basePath().replace(/[.*+?^${}()|[\]\\]/g, '\\$&')), '');
                const path = trimmed.replace(/^\/+|\/+$/g, '');
                // If we arrived via 404.html redirect (?path=...), replace URL with clean path for user friendliness
                if (pathParam) {
                    const newUrl = basePath() + (path ? '/' + path : '');
                    const hash = window.location.hash || '';
                    history.replaceState({}, '', newUrl + hash);
                }
                const segments = path.split('/').filter(Boolean);
                const last = segments.slice(-2);
                const maybeUser = last.length === 2 ? last[0] : null;
                const maybeDate = last.length === 2 ? last[1] : null;
                const maybeUserOnly = segments.length === 1 ? segments[0] : null;

                const hash = window.location.hash || '';
                if (hash.startsWith('#public')) {
                    return mount.appendChild(PublicList());
                }

                if (maybeUser && /^(?:\d{4}-\d{2}-\d{2}|\d{2}-\d{2}-\d{4})$/.test(maybeDate)) {
                    return mount.appendChild(PublicEntry(maybeUser, toIsoDate(maybeDate)));
                }

                // Route: /:username → public calendar for that user
                if (maybeUserOnly && !/^\d{4}-\d{2}-\d{2}$/.test(maybeUserOnly)) {
                    return mount.appendChild(PublicUser(maybeUserOnly));
                }

                if (auth.user) {
                    q('#nav-logout').style.display = 'inline';
                    return mount.appendChild(Dashboard());
                } else {
                    q('#nav-logout').style.display = 'none';
                    return mount.appendChild(AuthPage());
                }
            }

            function AuthPage() {
                const node = el(`
      <div class="row">
        <div class="col" style="flex:1 1 480px;">
          <div class="card" style="max-width:560px;margin:0 auto;">
            <h3 style="margin-top:0;margin-bottom:8px;">Welcome back</h3>
            <div class="helper" style="margin-bottom:12px;">Login to write your diary. New here? Create an account below.</div>
            <label>Username or Email</label>
            <input id="login-identifier" placeholder="you@example.com or username" />
            <div class="spacer"></div>
            <label>Password</label>
            <input id="login-password" type="password" />
            <div class="spacer"></div>
            <button id="btn-login" style="width:100%;">Login</button>
            <div class="spacer"></div>
            <div class="helper">No account?</div>
            <div class="spacer" style="height:8px"></div>
            <label>Email</label>
            <input id="reg-email" placeholder="you@example.com" />
            <div class="spacer"></div>
            <label>Username</label>
            <input id="reg-username" placeholder="yourname" />
            <div class="spacer"></div>
            <label>Password</label>
            <input id="reg-password" type="password" />
            <div class="spacer"></div>
            <button id="btn-register" class="ghost" style="width:100%;">Create account</button>
            <div class="spacer"></div>
            <span class="helper" id="auth-msg"></span>
          </div>
        </div>
      </div>
    `);

                node.querySelector('#btn-login').addEventListener('click', async () => {
                    const identifier = node.querySelector('#login-identifier').value.trim();
                    const password = node.querySelector('#login-password').value;
                    const msg = node.querySelector('#auth-msg');
                    msg.textContent = '';
                    try {
                        const res = await apiPost({ action: 'login', identifier, password });
                        if (res.success) {
                            auth.user = res.user; // {id,email,username}
                            render();
                        } else {
                            msg.textContent = res.error || res.message || 'Login failed';
                            msg.className = 'helper error';
                        }
                    } catch (e) { msg.textContent = e.message; msg.className = 'helper error'; }
                });

                node.querySelector('#btn-register').addEventListener('click', async () => {
                    const email = node.querySelector('#reg-email').value.trim();
                    const username = node.querySelector('#reg-username').value.trim();
                    const password = node.querySelector('#reg-password').value;
                    const msg = node.querySelector('#auth-msg');
                    msg.textContent = '';
                    try {
                        const res = await apiPost({ action: 'register', email, username, password });
                        if (res.success) {
                            msg.textContent = 'Registered. You can now login.';
                            msg.className = 'helper success';
                        } else {
                            msg.textContent = res.error || res.message || 'Registration failed';
                            msg.className = 'helper error';
                        }
                    } catch (e) { msg.textContent = e.message; msg.className = 'helper error'; }
                });

                return node;
            }

            function Dashboard() {
                const user = auth.user;
                const node = el(`
      <div class="row">
        <div class="col">
          <div class="card">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
              <div>
                <h3>My Diary</h3>
                <div class="helper">Logged in as <span class="badge">${user.username}</span></div>
              </div>
              <div class="helper">Public: <span class="kbd">/${user.username}/DD-MM-YYYY</span></div>
            </div>
            <div class="spacer"></div>
            <div style="display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap">
              <button id="tab-editor">Editor</button>
              <button id="tab-calendar" class="ghost">Calendar</button>
              <button id="btn-edit" class="ghost">Edit</button>
            </div>
            <div id="section-editor">
            <label>Date</label>
            <input id="diary-date" type="date" value="${today()}" />
            <div class="spacer" style="height:8px"></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btn-prev-day" class="ghost">Prev day</button>
              <button id="btn-next-day" class="ghost">Next day</button>
            </div>
            <div class="spacer"></div>
            <label>Title</label>
            <input id="diary-title" placeholder="Optional title" />
            <div class="spacer"></div>
            <label>Content</label>
            <textarea id="diary-content" placeholder="Write your day..."></textarea>
            <div class="spacer"></div>
            <label>Privacy</label>
            <select id="diary-private">
              <option value="false">Public (anyone with link)</option>
              <option value="true">Private (only you)</option>
            </select>
            <div class="spacer"></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btn-save">Save</button>
              <button id="btn-update" class="ghost">Update</button>
              <button id="btn-delete" class="danger">Delete</button>
              <a id="permalink" class="link" target="_blank" rel="noopener">Open public link</a>
            </div>
            <div class="spacer"></div>
            <div id="dash-msg" class="notice" style="display:none"></div>
            </div>
            <div id="section-calendar" style="display:none">
              <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px">
                <button id="cal-prev" class="ghost">Prev</button>
                <div id="cal-label" class="badge"></div>
                <button id="cal-next" class="ghost">Next</button>
              </div>
              <div id="calendar"></div>
            </div>
          </div>
        </div>
        <div class="col">
          <div class="card">
            <h3>Recent entries</h3>
            <div id="recent-list" class="helper">Loading…</div>
          </div>
        </div>
      </div>
    `);

                const dateInput = node.querySelector('#diary-date');
                const titleInput = node.querySelector('#diary-title');
                const contentInput = node.querySelector('#diary-content');
                const privacySelect = node.querySelector('#diary-private');
                const msg = node.querySelector('#dash-msg');
                const permalink = node.querySelector('#permalink');
                const tabEditor = node.querySelector('#tab-editor');
                const tabCalendar = node.querySelector('#tab-calendar');
                const secEditor = node.querySelector('#section-editor');
                const secCalendar = node.querySelector('#section-calendar');
                const btnEdit = node.querySelector('#btn-edit');

                function setMsg(text, ok) { msg.textContent = text; msg.style.display = 'block'; msg.className = 'notice ' + (ok ? 'success' : 'error'); }
                function clearMsg() { msg.textContent = ''; msg.style.display = 'none'; }

                function setPermalink() {
                    const d = dateInput.value || today();
                    const base = window.location.origin + basePath();
                    const display = toDisplayDate(d);
                    permalink.href = base + '/' + encodeURIComponent(user.username) + '/' + display + '#public';
                    permalink.textContent = permalink.href;
                }
                setPermalink();

                // Tabs
                function showEditor() { secEditor.style.display = ''; secCalendar.style.display = 'none'; tabEditor.classList.remove('ghost'); tabCalendar.classList.add('ghost'); }
                function showCalendar() { secEditor.style.display = 'none'; secCalendar.style.display = ''; tabEditor.classList.add('ghost'); tabCalendar.classList.remove('ghost'); }
                tabEditor.addEventListener('click', showEditor);
                tabCalendar.addEventListener('click', showCalendar);

                // Edit mode toggle (read-only by default)
                let editMode = false;
                let currentHasEntry = false;
                let lastSavedSnapshot = { title: '', content: '', isPrivate: 'false', date: dateInput.value };
                let autosaveTimer = null;
                let autosaveInFlight = false;
                function applyEditMode() {
                    const disabled = !editMode;
                    titleInput.disabled = disabled;
                    contentInput.disabled = disabled;
                    privacySelect.disabled = disabled;
                    dateInput.disabled = false; // allow switching date even in view mode
                    q('#btn-save', node).style.display = editMode ? '' : 'none';
                    q('#btn-update', node).style.display = editMode ? '' : 'none';
                    q('#btn-delete', node).style.display = editMode ? '' : 'none';
                    btnEdit.textContent = editMode ? 'Done' : 'Edit';
                    if (editMode) {
                        if (!autosaveTimer) autosaveTimer = setInterval(tryAutoSave, 5000);
                    } else {
                        if (autosaveTimer) { clearInterval(autosaveTimer); autosaveTimer = null; }
                    }
                }
                btnEdit.addEventListener('click', async () => {
                    const wasEditing = editMode;
                    editMode = !editMode;
                    if (wasEditing && !editMode) {
                        await tryAutoSave(true);
                    }
                    applyEditMode();
                });
                applyEditMode();

                function isDirty() {
                    return (
                        lastSavedSnapshot.title !== titleInput.value ||
                        lastSavedSnapshot.content !== contentInput.value ||
                        String(lastSavedSnapshot.isPrivate) !== String(privacySelect.value) ||
                        lastSavedSnapshot.date !== (dateInput.value || today())
                    );
                }

                async function tryAutoSave(force) {
                    if (autosaveInFlight) return;
                    if (!force && !editMode) return;
                    if (!force && !isDirty()) return;
                    const hasContent = (contentInput.value || '').trim().length > 0;
                    if (!hasContent) return;
                    autosaveInFlight = true;
                    try {
                        if (currentHasEntry) { await update(); } else { await save(); currentHasEntry = true; }
                        lastSavedSnapshot = { title: titleInput.value, content: contentInput.value, isPrivate: privacySelect.value, date: dateInput.value || today() };
                    } finally {
                        autosaveInFlight = false;
                    }
                }

                // Calendar
                let calYear = new Date().getFullYear();
                let calMonth = new Date().getMonth(); // 0-11
                const calLabel = node.querySelector('#cal-label');
                const calPrev = node.querySelector('#cal-prev');
                const calNext = node.querySelector('#cal-next');
                const calHost = node.querySelector('#calendar');

                calPrev.addEventListener('click', () => { calMonth--; if (calMonth < 0) { calMonth = 11; calYear--; } renderCalendar(); });
                calNext.addEventListener('click', () => { calMonth++; if (calMonth > 11) { calMonth = 0; calYear++; } renderCalendar(); });

                async function renderCalendar() {
                    const first = new Date(calYear, calMonth, 1);
                    const monthStr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0');
                    calLabel.textContent = first.toLocaleString(undefined, { month: 'long', year: 'numeric' });
                    calHost.innerHTML = '';
                    const grid = document.createElement('div');
                    grid.style.display = 'grid';
                    grid.style.gridTemplateColumns = 'repeat(7,1fr)';
                    grid.style.gap = '8px';
                    const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    weekdays.forEach(d => { const h = document.createElement('div'); h.className = 'helper'; h.textContent = d; grid.appendChild(h); });
                    const startPad = first.getDay();
                    const daysInMonth = new Date(calYear, calMonth + 1, 0).getDate();
                    for (let i = 0; i < startPad; i++) { const pad = document.createElement('div'); grid.appendChild(pad); }
                    let entriesByDate = {};
                    // Prefer client cache if available
                    if (clientCache.userLoadedAll && clientCache.userEntries) {
                        for (const e of clientCache.userEntries) {
                            if (!e.date.startsWith(monthStr)) continue;
                            const list = entriesByDate[e.date] || (entriesByDate[e.date] = []);
                            list.push(e);
                        }
                    } else {
                        // fallback quick fetch for current month
                        try {
                            const res = await apiGet({ action: 'getUserDiaryEntries', userId: user.id, month: monthStr });
                            if (res.success && Array.isArray(res.entries)) {
                                for (const e of res.entries) {
                                    const list = entriesByDate[e.date] || (entriesByDate[e.date] = []);
                                    list.push(e);
                                }
                            }
                        } catch (err) { }
                    }
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dstr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                        const cell = document.createElement('div');
                        cell.style.border = '1px solid var(--border)';
                        cell.style.borderRadius = '10px';
                        cell.style.padding = '8px';
                        cell.style.minHeight = '72px';
                        cell.style.background = 'var(--input)';
                        const head = document.createElement('div'); head.className = 'helper'; head.textContent = day; cell.appendChild(head);
                        const list = entriesByDate[dstr] || [];
                        const count = list.length;
                        if (count > 0) {
                            const a = document.createElement('a'); a.className = 'link truncate'; a.href = `${basePath()}/${encodeURIComponent(user.username)}/${toDisplayDate(dstr)}`; a.target = '_blank'; a.rel = 'noopener';
                            const first = list[0];
                            a.textContent = (first.title || 'Untitled') + (first.isPrivate ? ' (private)' : '');
                            const p = document.createElement('div'); p.style.marginTop = '6px'; p.appendChild(a); cell.appendChild(p);
                            const badge = document.createElement('span'); badge.className = 'badge'; badge.textContent = String(count);
                            badge.style.float = 'right';
                            head.appendChild(badge);
                        } else {
                            const p = document.createElement('div'); p.className = 'helper'; p.style.marginTop = '6px'; p.textContent = '—'; cell.appendChild(p);
                        }
                        cell.addEventListener('click', () => { dateInput.value = dstr; showEditor(); setPermalink(); });
                        grid.appendChild(cell);
                    }
                    calHost.appendChild(grid);
                }

                // default to Editor; user can open Calendar tab
                renderCalendar();

                async function loadRecent() {
                    try {
                        // Prefer cache if loaded
                        if (clientCache.userLoadedAll && Array.isArray(clientCache.userEntries)) {
                            const wrap = node.querySelector('#recent-list');
                            if (clientCache.userEntries.length === 0) { wrap.textContent = 'No entries yet.'; return; }
                            const list = document.createElement('div');
                            clientCache.userEntries.slice(0, 20).forEach(e => {
                                const item = document.createElement('div');
                                item.style.marginBottom = '10px';

                                const a = document.createElement('a');
                                a.className = 'link';
                                a.href = `${basePath()}/${encodeURIComponent(user.username)}/${toDisplayDate(e.date)}`;
                                a.textContent = `${toDisplayDate(e.date)} — ${e.title || 'Untitled'} ${e.isPrivate ? '(private)' : ''}`;
                                a.target = '_blank'; a.rel = 'noopener';

                                const preview = document.createElement('div');
                                preview.className = 'helper';
                                const text = String(e.content || '').replace(/\s+/g, ' ').trim();
                                const snippet = text.length > 160 ? text.slice(0, 160) + '…' : text;
                                preview.textContent = snippet || '—';

                                item.appendChild(a);
                                item.appendChild(preview);
                                list.appendChild(item);
                            });
                            wrap.innerHTML = ''; wrap.appendChild(list);
                            return;
                        }

                        const res = await apiGet({ action: 'getUserDiaryEntries', userId: user.id });
                        const wrap = node.querySelector('#recent-list');
                        if (!res.success) { wrap.textContent = res.error || 'Failed to load'; return; }
                        if (!res.entries || res.entries.length === 0) { wrap.textContent = 'No entries yet.'; return; }
                        const list = document.createElement('div');
                        res.entries.slice(0, 20).forEach(e => {
                            const item = document.createElement('div');
                            item.style.marginBottom = '10px';

                            const a = document.createElement('a');
                            a.className = 'link';
                            a.href = `${basePath()}/${encodeURIComponent(user.username)}/${toDisplayDate(e.date)}`;
                            a.textContent = `${toDisplayDate(e.date)} — ${e.title || 'Untitled'} ${e.isPrivate ? '(private)' : ''}`;
                            a.target = '_blank'; a.rel = 'noopener';

                            const preview = document.createElement('div');
                            preview.className = 'helper';
                            const text = String(e.content || '').replace(/\s+/g, ' ').trim();
                            const snippet = text.length > 160 ? text.slice(0, 160) + '…' : text;
                            preview.textContent = snippet || '—';

                            item.appendChild(a);
                            item.appendChild(preview);
                            list.appendChild(item);
                        });
                        wrap.innerHTML = ''; wrap.appendChild(list);
                    } catch (e) { const wrap = node.querySelector('#recent-list'); wrap.textContent = e.message; }
                }

                async function load() {
                    clearMsg();
                    try {
                        const d = dateInput.value || today();
                        // Use private/self endpoint first
                        let ok = false;
                        currentHasEntry = false;
                        // If cache has the entry, use it
                        if (clientCache.userLoadedAll && clientCache.userEntriesByDate[d] && clientCache.userEntriesByDate[d].length > 0) {
                            const ownEntry = clientCache.userEntriesByDate[d][0];
                            titleInput.value = ownEntry.title || '';
                            contentInput.value = ownEntry.content || '';
                            privacySelect.value = String(!!ownEntry.isPrivate);
                            ok = true; currentHasEntry = true;
                        } else {
                            const own = await apiGet({ action: 'getUserDiaryEntry', userId: user.id, date: d });
                            if (own.success && own.entry) {
                                titleInput.value = own.entry.title || '';
                                contentInput.value = own.entry.content || '';
                                privacySelect.value = String(!!own.entry.isPrivate);
                                ok = true; currentHasEntry = true;
                            } else {
                                // Fallback to public view if this date is public and username/date requested directly
                                try {
                                    const pub = await apiGet({ action: 'getDiaryEntry', username: user.username, date: d });
                                    if (pub.success && pub.entry) {
                                        titleInput.value = pub.entry.title || '';
                                        contentInput.value = pub.entry.content || '';
                                        ok = true;
                                    }
                                } catch (e) { }
                            }
                        }
                        lastSavedSnapshot = { title: titleInput.value, content: contentInput.value, isPrivate: privacySelect.value, date: d };
                        if (ok) setMsg('Loaded entry for ' + toDisplayDate(d), true);
                        else { titleInput.value = ''; contentInput.value = ''; setMsg('No entry for ' + toDisplayDate(d), false); }
                    } catch (e) { setMsg(e.message, false); }
                }

                async function save() {
                    clearMsg();
                    const payload = {
                        action: 'saveDiaryEntry',
                        userId: user.id,
                        date: dateInput.value || today(),
                        title: titleInput.value,
                        content: contentInput.value,
                        isPrivate: privacySelect.value
                    };
                    try {
                        const res = await apiPost(payload);
                        if (res.success) {
                            setMsg('Saved.', true);
                            // update client cache
                            const entry = { date: payload.date, title: payload.title, content: payload.content, isPrivate: payload.isPrivate === 'true' || payload.isPrivate === true };
                            if (!Array.isArray(clientCache.userEntries)) clientCache.userEntries = [];
                            clientCache.userEntries.unshift(entry);
                            clientCache.userLoadedAll = true;
                            clientCache.userEntriesByDate[payload.date] = [entry];
                            currentHasEntry = true;
                            // re-render dependents
                            renderCalendar();
                            loadRecent();
                        }
                        else { setMsg(res.error || res.message || 'Save failed', false); }
                    } catch (e) { setMsg(e.message, false); }
                }

                async function update() {
                    clearMsg();
                    const payload = {
                        action: 'updateDiaryEntry',
                        userId: user.id,
                        date: dateInput.value || today(),
                        title: titleInput.value,
                        content: contentInput.value,
                        isPrivate: privacySelect.value
                    };
                    try {
                        const res = await apiPost(payload);
                        if (res.success) {
                            setMsg('Updated.', true);
                            // update client cache
                            if (Array.isArray(clientCache.userEntries)) {
                                for (const e of clientCache.userEntries) { if (e.date === payload.date) { e.title = payload.title; e.content = payload.content; e.isPrivate = payload.isPrivate === 'true' || payload.isPrivate === true; break; } }
                            }
                            clientCache.userEntriesByDate[payload.date] = [{ date: payload.date, title: payload.title, content: payload.content, isPrivate: payload.isPrivate === 'true' || payload.isPrivate === true }];
                            renderCalendar();
                            loadRecent();
                        }
                        else { setMsg(res.error || res.message || 'Update failed', false); }
                    } catch (e) { setMsg(e.message, false); }
                }

                async function remove() {
                    if (!confirm('Delete this entry?')) return;
                    clearMsg();
                    try {
                        const res = await apiPost({ action: 'deleteDiaryEntry', userId: user.id, date: dateInput.value || today() });
                        if (res.success) {
                            titleInput.value = ''; contentInput.value = '';
                            setMsg('Deleted.', true);
                            const d = dateInput.value || today();
                            if (Array.isArray(clientCache.userEntries)) { clientCache.userEntries = clientCache.userEntries.filter(e => e.date !== d); }
                            delete clientCache.userEntriesByDate[d];
                            currentHasEntry = false;
                            renderCalendar();
                            loadRecent();
                        }
                        else { setMsg(res.error || 'Delete failed', false); }
                    } catch (e) { setMsg(e.message, false); }
                }

                node.querySelector('#btn-save').addEventListener('click', save);
                node.querySelector('#btn-update').addEventListener('click', update);
                node.querySelector('#btn-delete').addEventListener('click', remove);
                dateInput.addEventListener('change', () => { setPermalink(); load(); });
                node.querySelector('#btn-prev-day').addEventListener('click', () => { dateInput.value = addDaysIso(dateInput.value || today(), -1); setPermalink(); load(); });
                node.querySelector('#btn-next-day').addEventListener('click', () => { dateInput.value = addDaysIso(dateInput.value || today(), 1); setPermalink(); load(); });

                // Initial quick load of today's entry in view mode
                setMsg('Loading…', true);
                load().finally(() => { applyEditMode(); });

                // Prefetch all user entries once in background
                (async function prefetchAll() {
                    try {
                        const res = await apiGet({ action: 'getUserDiaryEntries', userId: user.id });
                        if (res.success && Array.isArray(res.entries)) {
                            clientCache.userEntries = res.entries;
                            clientCache.userEntriesByDate = {};
                            for (const e of res.entries) {
                                const list = clientCache.userEntriesByDate[e.date] || (clientCache.userEntriesByDate[e.date] = []);
                                list.push(e);
                            }
                            clientCache.userLoadedAll = true;
                            // refresh calendar and recent to avoid waiting later
                            renderCalendar();
                            loadRecent();
                            clearMsg();
                        } else { clearMsg(); }
                    } catch (e) { clearMsg(); }
                })();

                loadRecent();
                return node;
            }

            function PublicEntry(username, date) {
                const node = el(`
      <div class="card">
        <h3>Public diary</h3>
        <div class="helper">${username} · ${toDisplayDate(date)}</div>
        <div class="spacer"></div>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="pub-prev" class="ghost">Prev day</button>
          <button id="pub-next" class="ghost">Next day</button>
        </div>
        <div class="spacer"></div>
        <div id="pub-msg" class="notice" style="display:none"></div>
        <div id="pub-title" style="font-weight:600;font-size:16px;margin-bottom:6px"></div>
        <pre id="pub-content" style="white-space:pre-wrap;background:#0c121a;border:1px solid var(--border);padding:12px;border-radius:10px"></pre>
      </div>
    `);

                const msg = node.querySelector('#pub-msg');
                function setMsg(text, ok) { msg.textContent = text; msg.style.display = 'block'; msg.className = 'notice ' + (ok ? 'success' : 'error'); }

                async function renderFromCacheOrFetch() {
                    const cached = clientCache.publicByUser.get(username);
                    if (cached && cached.byDate && cached.byDate[date] && cached.byDate[date].length) {
                        const e = cached.byDate[date][0];
                        node.querySelector('#pub-title').textContent = e.title || '';
                        node.querySelector('#pub-content').textContent = e.content || '';
                        setMsg('Public entry', true);
                        return true;
                    }
                    return false;
                }

                (async function () {
                    setMsg('Loading…', true);
                    try {
                        const servedFromCache = await renderFromCacheOrFetch();
                        if (!servedFromCache) {
                            const res = await apiGet({ action: 'getDiaryEntry', username, date });
                            if (res.success && res.entry) {
                                node.querySelector('#pub-title').textContent = res.entry.title || '';
                                node.querySelector('#pub-content').textContent = res.entry.content || '';
                                setMsg('Public entry', true);
                            } else {
                                setMsg(res.error || 'Not found or private', false);
                            }
                        }
                        if (!clientCache.publicByUser.has(username)) clientCache.publicByUser.set(username, { entries: [], byDate: {} });
                        (async function prefetchAllPublic() {
                            try {
                                const monthStr = date.slice(0, 7);
                                const month = await apiGet({ action: 'getPublicDiaryEntries', username, month: monthStr, maxContent: '220' });
                                const storeExisting = clientCache.publicByUser.get(username) || { entries: [], byDate: {} };
                                if (month.success && Array.isArray(month.entries)) {
                                    for (const e of month.entries) { const list = storeExisting.byDate[e.date] || (storeExisting.byDate[e.date] = []); if (!list.find(x => x.date === e.date && x.title === e.title)) list.push(e); }
                                    storeExisting.entries = storeExisting.entries.concat(month.entries);
                                    clientCache.publicByUser.set(username, storeExisting);
                                }
                                const all = await apiGet({ action: 'getPublicDiaryEntries', username, limit: '500' });
                                if (all.success && Array.isArray(all.entries)) {
                                    const store = { entries: all.entries, byDate: {} };
                                    for (const e of all.entries) { const list = store.byDate[e.date] || (store.byDate[e.date] = []); list.push(e); }
                                    clientCache.publicByUser.set(username, store);
                                    await renderFromCacheOrFetch();
                                }
                            } catch (e) {}
                        })();
                    } catch (e) { setMsg(e.message, false); }
                })();

                // Prev/Next day navigation
                node.querySelector('#pub-prev').addEventListener('click', () => {
                    const prev = addDaysIso(date, -1);
                    history.pushState({}, '', basePath() + '/' + encodeURIComponent(username) + '/' + toDisplayDate(prev));
                    render();
                });
                node.querySelector('#pub-next').addEventListener('click', () => {
                    const next = addDaysIso(date, 1);
                    history.pushState({}, '', basePath() + '/' + encodeURIComponent(username) + '/' + toDisplayDate(next));
                    render();
                });

                return node;
            }

            function PublicList() {
                const node = el(`
      <div class="card">
        <h3>Latest public entries</h3>
        <div id="pub-list" class="helper">Loading…</div>
      </div>
    `);

                (async function () {
                    try {
                        const res = await apiGet({ action: 'getPublicDiaryEntries', limit: '50', maxContent: '220' });
                        const wrap = node.querySelector('#pub-list');
                        if (!res.success) { wrap.textContent = res.error || 'Failed to load'; return; }
                        if (!res.entries || res.entries.length === 0) { wrap.textContent = 'No public entries yet.'; return; }
                        const list = document.createElement('div');
                        res.entries.slice(0, 50).forEach(e => {
                            const item = document.createElement('div');
                            item.style.marginBottom = '10px';
                            item.style.border = '1px solid var(--border)';
                            item.style.borderRadius = '10px';
                            item.style.padding = '10px';
                            item.style.background = 'var(--input)';

                            const a = document.createElement('a');
                            a.className = 'link';
                            a.href = `${basePath()}/${encodeURIComponent(e.username)}/${toDisplayDate(e.date)}`;
                            a.textContent = `${toDisplayDate(e.date)} – ${e.username}: ${e.title || 'Untitled'}`;
                            a.target = '_blank'; a.rel = 'noopener';

                            const preview = document.createElement('div');
                            preview.className = 'helper';
                            preview.style.marginTop = '6px';
                            const text = String(e.content || '').replace(/\s+/g, ' ').trim();
                            const snippet = text.length > 160 ? text.slice(0, 160) + '…' : text;
                            preview.textContent = snippet || '—';

                            item.appendChild(a);
                            item.appendChild(preview);
                            list.appendChild(item);
                        });
                        wrap.innerHTML = ''; wrap.appendChild(list);
                    } catch (e) { node.querySelector('#pub-list').textContent = e.message; }
                })();

                return node;
            }

            function PublicUser(username) {
                const node = el(`
      <div class="card">
        <h3>Public calendar</h3>
        <div class="helper">${username}</div>
        <div class="spacer"></div>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px">
          <button id="cal-prev" class="ghost">Prev</button>
          <div id="cal-label" class="badge"></div>
          <button id="cal-next" class="ghost">Next</button>
        </div>
        <div id="calendar"></div>
        <div class="spacer"></div>
        <div id="month-strip"></div>
      </div>
    `);

                let calYear = new Date().getFullYear();
                let calMonth = new Date().getMonth();
                const calLabel = node.querySelector('#cal-label');
                const calPrev = node.querySelector('#cal-prev');
                const calNext = node.querySelector('#cal-next');
                const calHost = node.querySelector('#calendar');

                let publicEntries = null; // month-first, then all

                calPrev.addEventListener('click', () => { calMonth--; if (calMonth < 0) { calMonth = 11; calYear--; } renderCalendar(); });
                calNext.addEventListener('click', () => { calMonth++; if (calMonth > 11) { calMonth = 0; calYear++; } renderCalendar(); });

                async function ensureEntries() {
                    // If background all-data cache exists, use it
                    const cachedUser = clientCache.publicByUser.get(username);
                    if (cachedUser && Array.isArray(cachedUser.entries) && cachedUser.entries.length) {
                        publicEntries = cachedUser.entries;
                        return publicEntries;
                    }
                    if (publicEntries) return publicEntries;
                    // Quick month fetch for fast first paint
                    try {
                        const monthStr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0');
                        const res = await apiGet({ action: 'getPublicDiaryEntries', username, month: monthStr, maxContent: '160' });
                        publicEntries = (res.success && Array.isArray(res.entries)) ? res.entries : [];
                    } catch (e) { publicEntries = []; }
                    // Background prefetch of all public entries for user
                    (async function prefetchAll() {
                        try {
                            const all = await apiGet({ action: 'getPublicDiaryEntries', username, limit: '500', maxContent: '220' });
                            if (all.success && Array.isArray(all.entries)) {
                                const store = { entries: all.entries, byDate: {} };
                                for (const e of all.entries) { const list = store.byDate[e.date] || (store.byDate[e.date] = []); list.push(e); }
                                clientCache.publicByUser.set(username, store);
                                publicEntries = all.entries;
                                // re-render current month with full data once ready
                                renderCalendar();
                            }
                        } catch (e) {}
                    })();
                    return publicEntries;
                }

                async function renderCalendar() {
                    const first = new Date(calYear, calMonth, 1);
                    const monthStr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0');
                    calLabel.textContent = first.toLocaleString(undefined, { month: 'long', year: 'numeric' });
                    calHost.innerHTML = '';
                    const loading = document.createElement('div'); loading.className = 'helper'; loading.textContent = 'Loading…'; calHost.appendChild(loading);
                    const grid = document.createElement('div');
                    grid.style.display = 'grid';
                    grid.style.gridTemplateColumns = 'repeat(7,1fr)';
                    grid.style.gap = '8px';
                    const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    weekdays.forEach(d => { const h = document.createElement('div'); h.className = 'helper'; h.textContent = d; grid.appendChild(h); });
                    const startPad = first.getDay();
                    const daysInMonth = new Date(calYear, calMonth + 1, 0).getDate();
                    for (let i = 0; i < startPad; i++) { const pad = document.createElement('div'); grid.appendChild(pad); }

                    const entries = await ensureEntries();
                    const entriesByDate = {};
                    for (const e of entries) {
                        const list = entriesByDate[e.date] || (entriesByDate[e.date] = []);
                        list.push(e);
                    }

                    calHost.innerHTML = '';
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dstr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                        const cell = document.createElement('div');
                        cell.style.border = '1px solid var(--border)';
                        cell.style.borderRadius = '10px';
                        cell.style.padding = '8px';
                        cell.style.minHeight = '72px';
                        cell.style.background = 'var(--input)';
                        const head = document.createElement('div'); head.className = 'helper'; head.textContent = day; cell.appendChild(head);
                        const list = entriesByDate[dstr] || [];
                        const count = list.length;
                        if (count > 0) {
                            const a = document.createElement('a'); a.className = 'link truncate'; a.href = `${basePath()}/${encodeURIComponent(username)}/${toDisplayDate(dstr)}`; a.target = '_blank'; a.rel = 'noopener';
                            const first = list[0];
                            a.textContent = (first.title || 'Untitled');
                            const p = document.createElement('div'); p.style.marginTop = '6px'; p.appendChild(a); cell.appendChild(p);
                            const badge = document.createElement('span'); badge.className = 'badge'; badge.textContent = String(count);
                            badge.style.float = 'right';
                            head.appendChild(badge);
                        } else {
                            const p = document.createElement('div'); p.className = 'helper'; p.style.marginTop = '6px'; p.textContent = '—'; cell.appendChild(p);
                        }
                        cell.addEventListener('click', () => { window.open(`${basePath()}/${encodeURIComponent(username)}/${toDisplayDate(dstr)}`, '_blank'); });
                        grid.appendChild(cell);
                    }
                    calHost.appendChild(grid);

                    // Month strip (narrow bar showing daily availability)
                    const strip = node.querySelector('#month-strip');
                    strip.innerHTML = '';
                    const stripGrid = document.createElement('div');
                    stripGrid.style.display = 'grid';
                    stripGrid.style.gridTemplateColumns = `repeat(${daysInMonth},1fr)`;
                    stripGrid.style.gap = '2px';
                    stripGrid.style.alignItems = 'stretch';
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dstr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                        const bar = document.createElement('div');
                        const has = (entriesByDate[dstr] || []).length > 0;
                        bar.style.height = '6px';
                        bar.style.borderRadius = '4px';
                        bar.style.background = has ? 'var(--accent)' : 'var(--border)';
                        bar.title = toDisplayDate(dstr);
                        bar.style.cursor = 'pointer';
                        bar.addEventListener('click', () => { window.open(`${basePath()}/${encodeURIComponent(username)}/${toDisplayDate(dstr)}`, '_blank'); });
                        stripGrid.appendChild(bar);
                    }
                    strip.appendChild(stripGrid);
                }

                renderCalendar();
                return node;
            }

            q('#nav-logout').addEventListener('click', (e) => { e.preventDefault(); auth.user = null; render(); });
            window.addEventListener('hashchange', render);
            window.addEventListener('popstate', render);

            // Initial render
            render();
        })();
    </script>
</body>

</html>