<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1" />
    <title>Diary</title>
    <link rel="preconnect" href="https://fonts.googleapis.com">
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;500;600;700&display=swap" rel="stylesheet">
    <style>
        :root {
            --bg: #0b0e14;
            --panel: #111620;
            --panel-2: #0f1420;
            --text: #e6edf3;
            --muted: #9aa5b1;
            --accent: #3b82f6;
            --accent-2: #60a5fa;
            --danger: #ef4444;
            --ok: #10b981;
            --border: #1f2937;
            --input: #0c121c
        }

        * {
            box-sizing: border-box
        }

        html,
        body {
            height: 100%
        }

        body {
            margin: 0;
            font-family: Inter, system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, "Apple Color Emoji", "Segoe UI Emoji";
            background: linear-gradient(180deg, #0b0e14, #0a0f1a 40%, #0b1220);
            color: var(--text)
        }

        .container {
            max-width: 960px;
            margin: 0 auto;
            padding: 24px
        }

        .header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 16px
        }

        .brand {
            font-weight: 700;
            letter-spacing: .4px
        }

        .nav a {
            color: var(--muted);
            text-decoration: none;
            margin-left: 16px
        }

        .card {
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid var(--border);
            border-radius: 12px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
            padding: 20px
        }

        .row {
            display: flex;
            gap: 16px;
            flex-wrap: wrap
        }

        .col {
            flex: 1 1 320px
        }

        label {
            display: block;
            font-size: 12px;
            color: var(--muted);
            margin-bottom: 6px
        }

        input,
        textarea,
        select,
        button {
            font: inherit
        }

        input,
        textarea,
        select {
            width: 100%;
            padding: 12px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: var(--input);
            color: var(--text)
        }

        textarea {
            min-height: 220px;
            resize: vertical
        }

        button {
            background: var(--accent);
            color: white;
            border: 0;
            border-radius: 10px;
            padding: 10px 14px;
            cursor: pointer
        }

        button.ghost {
            background: transparent;
            border: 1px solid var(--border);
            color: var(--text)
        }

        button.danger {
            background: var(--danger)
        }

        button:disabled {
            opacity: .6;
            cursor: not-allowed
        }

        .helper {
            font-size: 12px;
            color: var(--muted)
        }

        .spacer {
            height: 12px
        }

        hr {
            border: 0;
            border-top: 1px solid var(--border);
            margin: 16px 0
        }

        .badge {
            display: inline-block;
            padding: 4px 8px;
            border-radius: 999px;
            font-size: 12px;
            border: 1px solid var(--border);
            background: #0c121a;
            color: var(--muted)
        }

        .kbd {
            font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
            background: #0e1420;
            border: 1px solid var(--border);
            border-bottom-color: #111826;
            border-radius: 6px;
            padding: 2px 6px;
            color: #bcd;
        }

        .link {
            color: var(--accent-2);
            text-decoration: none
        }

        .footer {
            margin-top: 28px;
            color: var(--muted);
            font-size: 12px;
            text-align: center
        }

        .notice {
            padding: 10px 12px;
            border-radius: 10px;
            border: 1px solid var(--border);
            background: #0c1320;
            color: #cbd5e1
        }

        .error {
            color: #fecaca
        }

        .success {
            color: #bbf7d0
        }

        .truncate {
            display: block;
            overflow: hidden;
            white-space: nowrap;
            text-overflow: ellipsis
        }

        #app-overlay {
            position: fixed;
            inset: 0;
            display: grid;
            place-items: center;
            background: rgba(5, 8, 13, .92);
            color: var(--text);
            z-index: 9999
        }

        #app-overlay .box {
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid var(--border);
            border-radius: 12px;
            padding: 20px 24px;
            min-width: 260px;
            text-align: center;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .5)
        }
        #toast-container {
            position: fixed;
            top: 16px;
            right: 16px;
            display: flex;
            flex-direction: column;
            gap: 8px;
            z-index: 10000;
            pointer-events: none;
        }
        .toast {
            pointer-events: auto;
            background: linear-gradient(180deg, var(--panel), var(--panel-2));
            border: 1px solid var(--border);
            border-radius: 10px;
            padding: 10px 14px;
            color: var(--text);
            min-width: 260px;
            max-width: 360px;
            box-shadow: 0 10px 30px rgba(0, 0, 0, .35);
            position: relative;
            opacity: 0;
            transform: translateY(-8px);
            animation: toast-in 160ms ease-out forwards;
        }
        .toast.success { border-color: rgba(16,185,129,.35); }
        .toast.error { border-color: rgba(239,68,68,.35); }
        .toast .bar {
            position: absolute;
            left: 0;
            bottom: 0;
            height: 3px;
            background: var(--accent);
            width: 100%;
            transform-origin: left;
            animation: toast-bar 3s linear forwards;
        }
        .toast.error .bar { background: var(--danger); }
        .toast.success .bar { background: var(--ok); }
        .toast.out { animation: toast-out 140ms ease-in forwards; }
        @keyframes toast-in { from { opacity: 0; transform: translateY(-8px); } to { opacity: 1; transform: translateY(0); } }
        @keyframes toast-out { from { opacity: 1; transform: translateY(0); } to { opacity: 0; transform: translateY(-8px); } }
        @keyframes toast-bar { from { transform: scaleX(1); } to { transform: scaleX(0); } }
    </style>
</head>

<body>
    <div class="container">
        <div class="header">
            <div class="brand">Daily Diary</div>
            <div class="nav">
                <a id="nav-home" href="#">Home</a>
                <a id="nav-public" href="#public">Public</a>
                <a id="nav-logout" href="#" style="display:none">Logout</a>
            </div>
        </div>

        <div id="route-view"></div>

        <div class="footer">Make By PEPSEALSEA ©2025
        </div>
    </div>
    <div id="app-overlay">
        <div class="box">
            <div style="font-weight:600;margin-bottom:6px">Loading…</div>
            <div class="helper">Preparing your diary</div>
        </div>
    </div>
    <div id="toast-container" aria-live="polite" aria-atomic="true"></div>

    <script>
        (function () {
            const API_URL = 'https://script.google.com/macros/s/AKfycbxR7BQFNg_LHPspcMYXLpdwMQ6Ql6fzr1DVDryXCYdW4aPJlvb4oXFPx-Tng4ofmQLvmw/exec';
            const storage = {
                set(k, v, days) {
                    const value = typeof v === 'string' ? v : JSON.stringify(v);
                    const expires = days ? "; max-age=" + (days * 24 * 60 * 60) : '';
                    document.cookie = encodeURIComponent(k) + "=" + encodeURIComponent(value) + expires + "; path=/";
                },
                get(k) {
                    const name = encodeURIComponent(k) + "=";
                    const parts = document.cookie.split('; ');
                    for (const p of parts) {
                        if (p.startsWith(name)) {
                            const val = decodeURIComponent(p.substring(name.length));
                            try { return JSON.parse(val); } catch { return val; }
                        }
                    }
                    return null;
                },
                del(k) {
                    document.cookie = encodeURIComponent(k) + "=; expires=Thu, 01 Jan 1970 00:00:00 GMT; path=/";
                }
            };

            const auth = {
                get user() { return storage.get('diary_user'); },
                set user(u) { if (u) storage.set('diary_user', u, 30); else storage.del('diary_user'); }
            };
            function viewerEmail() { return (auth.user && auth.user.email) ? auth.user.email : ''; }

            function q(sel, root = document) { return root.querySelector(sel); }
            function el(html) { const t = document.createElement('template'); t.innerHTML = html.trim(); return t.content.firstChild; }
            const clientCache = {
                userEntries: null, // Array of all entries for logged-in user
                userEntriesByDate: {}, // date -> entries[]
                userLoadedAll: false,
                userEmptyDates: new Set(), // dates confirmed to have no private entry
                publicByUser: new Map(), // username -> {entries: [], byDate: {}, emptyDates: Set}
            };
            function fmtDate(d) {
                const x = new Date(d);
                const y = x.getFullYear();
                const m = String(x.getMonth() + 1).padStart(2, '0');
                const day = String(x.getDate()).padStart(2, '0');
                return y + '-' + m + '-' + day; // local date, not UTC
            }
            function today() { return fmtDate(new Date()); }
            function toDisplayDate(iso) {
                // iso: YYYY-MM-DD -> DD-MM-YYYY
                if (!iso || !/^\d{4}-\d{2}-\d{2}$/.test(iso)) return iso || '';
                const [y, m, d] = iso.split('-');
                return d + '-' + m + '-' + y;
            }
            function toIsoDate(maybe) {
                // Accept DD-MM-YYYY or YYYY-MM-DD and normalize to ISO
                if (!maybe) return '';
                if (/^\d{4}-\d{2}-\d{2}$/.test(maybe)) return maybe;
                const m = maybe.match(/^(\d{2})-(\d{2})-(\d{4})$/);
                if (m) return m[3] + '-' + m[2] + '-' + m[1];
                return fmtDate(maybe);
            }
            function addDaysIso(iso, delta) {
                const d = new Date(toIsoDate(iso));
                d.setDate(d.getDate() + delta);
                return fmtDate(d);
            }
            function basePath() {
                const segs = location.pathname.split('/').filter(Boolean);
                return segs.length ? '/' + segs[0] : '';
            }

            async function apiGet(params) {
                if (!API_URL) { throw new Error('API URL not configured'); }
                const merged = Object.assign({}, params);
                if (merged && (merged.action === 'getDiaryEntry' || merged.action === 'getPublicDiaryEntries')) {
                    if (viewerEmail()) merged.viewerEmail = viewerEmail();
                }
                const qs = new URLSearchParams(merged).toString();
                const res = await fetch(API_URL + '?' + qs, { method: 'GET' });
                return res.json();
            }
            async function apiPost(params) {
                if (!API_URL) { throw new Error('API URL not configured'); }
                const merged = Object.assign({}, params);
                if (merged && (merged.action === 'getDiaryEntry' || merged.action === 'getPublicDiaryEntries')) {
                    if (viewerEmail()) merged.viewerEmail = viewerEmail();
                }
                const form = new URLSearchParams(merged);
                const res = await fetch(API_URL, { method: 'POST', headers: { 'Content-Type': 'application/x-www-form-urlencoded' }, body: form.toString() });
                return res.json();
            }

            function show(elm) { elm.style.display = ''; }
            function hide(elm) { elm.style.display = 'none'; }
            function hideOverlay() { const o = q('#app-overlay'); if (o) o.style.display = 'none'; }

            let __lastToast = { text: '', time: 0 };
            function toast(text, ok, force) {
                const host = q('#toast-container') || (() => { const d = document.createElement('div'); d.id = 'toast-container'; document.body.appendChild(d); return d; })();
                const now = Date.now();
                const msgText = String(text || '');
                if (!force && __lastToast.text === msgText && (now - __lastToast.time) < 1500) {
                    return null;
                }
                __lastToast = { text: msgText, time: now };
                const t = document.createElement('div');
                t.className = 'toast ' + (ok ? 'success' : 'error');
                t.setAttribute('role', 'status');
                t.setAttribute('aria-live', 'polite');
                const content = document.createElement('div');
                content.textContent = msgText;
                const bar = document.createElement('div');
                bar.className = 'bar';
                t.appendChild(content);
                t.appendChild(bar);
                host.appendChild(t);
                let removed = false;
                function removeToast() {
                    if (removed) return; removed = true;
                    t.classList.add('out');
                    setTimeout(() => { if (t.parentNode) t.parentNode.removeChild(t); }, 180);
                }
                const timer = setTimeout(removeToast, 3000);
                t.addEventListener('click', () => { clearTimeout(timer); removeToast(); });
                return t;
            }

            function render() {
                const mount = q('#route-view');
                mount.innerHTML = '';

                const qp = new URLSearchParams(window.location.search);
                const pathParam = qp.get('path');
                const rawPath = pathParam || window.location.pathname;
                const trimmed = rawPath.replace(new RegExp('^' + basePath().replace(/[.*+?^${}()|[\]\\]/g, '\\$&')), '');
                const path = trimmed.replace(/^\/+|\/+$/g, '');
                // If we arrived via 404.html redirect (?path=...), replace URL with clean path for user friendliness
                if (pathParam) {
                    const newUrl = basePath() + (path ? '/' + path : '');
                    const hash = window.location.hash || '';
                    history.replaceState({}, '', newUrl + hash);
                }
                const segments = path.split('/').filter(Boolean);
                const last = segments.slice(-2);
                const maybeUser = last.length === 2 ? last[0] : null;
                const maybeDate = last.length === 2 ? last[1] : null;
                const maybeUserOnly = segments.length === 1 ? segments[0] : null;

                const hash = window.location.hash || '';
                if (hash.startsWith('#public')) {
                    const n = PublicList();
                    hideOverlay();
                    return mount.appendChild(n);
                }

                if (maybeUser && /^(?:\d{4}-\d{2}-\d{2}|\d{2}-\d{2}-\d{4})$/.test(maybeDate)) {
                    const n = PublicEntry(maybeUser, toIsoDate(maybeDate));
                    // overlay will be hidden by PublicEntry after first fetch
                    return mount.appendChild(n);
                }

                // Route: /:username → public calendar for that user
                if (maybeUserOnly && !/^\d{4}-\d{2}-\d{2}$/.test(maybeUserOnly)) {
                    const n = PublicUser(maybeUserOnly);
                    // overlay will be hidden after initial calendar render
                    return mount.appendChild(n);
                }

                if (auth.user) {
                    q('#nav-logout').style.display = 'inline';
                    const n = Dashboard();
                    // overlay will be hidden inside once initial load completes
                    return mount.appendChild(n);
                } else {
                    q('#nav-logout').style.display = 'none';
                    const n = AuthPage();
                    hideOverlay();
                    return mount.appendChild(n);
                }
            }

            function AuthPage() {
                const node = el(`
      <div class="row">
        <div class="col" style="flex:1 1 480px;">
          <div class="card" style="max-width:560px;margin:0 auto;">
            <h3 style="margin-top:0;margin-bottom:8px;">Welcome back</h3>
            <div class="helper" style="margin-bottom:12px;">Login to write your diary. New here? Create an account below.</div>
            <label>Username or Email</label>
            <input id="login-identifier" placeholder="you@example.com or username" />
            <div class="spacer"></div>
            <label>Password</label>
            <input id="login-password" type="password" />
            <div class="spacer"></div>
            <button id="btn-login" style="width:100%;">Login</button>
            <div class="spacer"></div>
            <div class="helper">No account?</div>
            <div class="spacer" style="height:8px"></div>
            <label>Email</label>
            <input id="reg-email" placeholder="you@example.com" />
            <div class="spacer"></div>
            <label>Username</label>
            <input id="reg-username" placeholder="yourname" />
            <div class="spacer"></div>
            <label>Password</label>
            <input id="reg-password" type="password" />
            <div class="spacer"></div>
            <button id="btn-register" class="ghost" style="width:100%;">Create account</button>
            <div class="spacer"></div>
            <span class="helper" id="auth-msg"></span>
          </div>
        </div>
      </div>
    `);

                node.querySelector('#btn-login').addEventListener('click', async () => {
                    const identifier = node.querySelector('#login-identifier').value.trim();
                    const password = node.querySelector('#login-password').value;
                    const msg = node.querySelector('#auth-msg');
                    msg.textContent = '';
                    try {
                        const res = await apiPost({ action: 'login', identifier, password });
                        if (res.success) {
                            auth.user = res.user; // {id,email,username}
                            render();
                        } else {
                            msg.textContent = res.error || res.message || 'Login failed';
                            msg.className = 'helper error';
                        }
                    } catch (e) { msg.textContent = e.message; msg.className = 'helper error'; }
                });

                node.querySelector('#btn-register').addEventListener('click', async () => {
                    const email = node.querySelector('#reg-email').value.trim();
                    const username = node.querySelector('#reg-username').value.trim();
                    const password = node.querySelector('#reg-password').value;
                    const msg = node.querySelector('#auth-msg');
                    msg.textContent = '';
                    try {
                        const res = await apiPost({ action: 'register', email, username, password });
                        if (res.success) {
                            msg.textContent = 'Registered. You can now login.';
                            msg.className = 'helper success';
                        } else {
                            msg.textContent = res.error || res.message || 'Registration failed';
                            msg.className = 'helper error';
                        }
                    } catch (e) { msg.textContent = e.message; msg.className = 'helper error'; }
                });

                return node;
            }

            function Dashboard() {
                const user = auth.user;
                const node = el(`
      <div class="row">
        <div class="col">
          <div class="card">
            <div style="display:flex;justify-content:space-between;align-items:center;gap:12px;flex-wrap:wrap">
              <div>
                <h3>My Diary</h3>
                <div class="helper">Logged in as <span class="badge">${user.username}</span></div>
              </div>
              <div class="helper">Public: <span class="kbd">/${user.username}/DD-MM-YYYY</span></div>
            </div>
            <div class="spacer"></div>
            <div style="display:flex;gap:8px;margin-bottom:12px;flex-wrap:wrap">
              <button id="tab-editor">Editor</button>
              <button id="tab-calendar" class="ghost">Calendar</button>
              <button id="btn-edit" class="ghost">Edit</button>
            </div>
            <div id="section-editor">
            <label>Date</label>
            <input id="diary-date" type="date" value="${today()}" />
            <div class="spacer" style="height:8px"></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btn-prev-day" class="ghost">Prev day</button>
              <button id="btn-next-day" class="ghost">Next day</button>
              <button id="btn-refresh" class="ghost">Refresh</button>
            </div>
            <div class="spacer"></div>
            <label>Title</label>
            <input id="diary-title" placeholder="Optional title" />
            <div class="spacer"></div>
            <label>Content</label>
            <textarea id="diary-content" placeholder="Write your day..."></textarea>
            <div class="spacer"></div>
            <label>Privacy</label>
            <select id="diary-private">
              <option value="public">Public (anyone)</option>
              <option value="friend">Friend (approved users)</option>
              <option value="private">Private (only you)</option>
            </select>
            <div class="spacer"></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <button id="btn-save">Save</button>
              <button id="btn-update" class="ghost">Update</button>
              <button id="btn-delete" class="danger">Delete</button>
              <a id="permalink" class="link" target="_blank" rel="noopener">Open public link</a>
            </div>
            <div class="spacer"></div>
            <div id="dash-msg" class="notice" style="display:none"></div>
            <div id="autosave-indicator" class="helper" style="display:none;color:var(--accent-2);font-size:11px;margin-top:8px;">
              <span id="autosave-status">Auto-save active</span>
            </div>
            </div>
            <div id="section-calendar" style="display:none">
              <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px">
                <button id="cal-prev" class="ghost">Prev</button>
                <div id="cal-label" class="badge"></div>
                <button id="cal-next" class="ghost">Next</button>
              </div>
              <div id="calendar"></div>
            </div>
          </div>
        </div>
        <div class="col">
          <div class="card">
            <h3>Recent entries</h3>
            <div id="recent-list" class="helper">Loading…</div>
          </div>
          <div class="card" style="margin-top:16px">
            <h3>Friends</h3>
            <div id="friends-list" class="helper">Loading…</div>
            <div class="spacer"></div>
            <div style="display:flex;gap:8px;flex-wrap:wrap">
              <input id="friend-identifier" placeholder="email, username, or userId" style="flex:1 1 240px" />
              <button id="btn-add-friend">Add</button>
              <button id="btn-refresh-friends" class="ghost">Refresh</button>
            </div>
          </div>
        </div>
      </div>
    `);
                // Friends management
                async function loadFriends() {
                    const wrap = node.querySelector('#friends-list');
                    try {
                        const res = await apiGet({ action: 'listFriends', ownerId: user.id });
                        if (!res.success) { wrap.textContent = res.error || 'Failed to load'; return; }
                        if (!res.friends || res.friends.length === 0) { wrap.textContent = 'No friends yet.'; return; }
                        const list = document.createElement('div');
                        res.friends.forEach(f => {
                            const row = document.createElement('div');
                            row.style.display = 'flex';
                            row.style.justifyContent = 'space-between';
                            row.style.alignItems = 'center';
                            row.style.marginBottom = '8px';
                            const left = document.createElement('div');
                            left.className = 'helper';
                            left.textContent = (f.friendEmail || '') + (f.friendUserId ? (f.friendEmail ? ' · ' : '') + f.friendUserId : '');
                            const btn = document.createElement('button');
                            btn.className = 'danger';
                            btn.textContent = 'Remove';
                            btn.addEventListener('click', async () => {
                                try {
                                    const res = await apiPost({ action: 'removeFriend', ownerId: user.id, friendIdentifier: f.friendUserId || f.friendEmail });
                                    if (res.success) loadFriends();
                                } catch (e) {}
                            });
                            row.appendChild(left);
                            row.appendChild(btn);
                            list.appendChild(row);
                        });
                        wrap.innerHTML = '';
                        wrap.appendChild(list);
                    } catch (e) { wrap.textContent = e.message; }
                }
                node.querySelector('#btn-add-friend').addEventListener('click', async () => {
                    const input = node.querySelector('#friend-identifier');
                    const val = input.value.trim();
                    if (!val) return;
                    try {
                        const res = await apiPost({ action: 'addFriend', ownerId: user.id, friendIdentifier: val });
                        if (res.success) { input.value = ''; loadFriends(); }
                    } catch (e) {}
                });
                node.querySelector('#btn-refresh-friends').addEventListener('click', loadFriends);
                loadFriends();

                const dateInput = node.querySelector('#diary-date');
                const titleInput = node.querySelector('#diary-title');
                const contentInput = node.querySelector('#diary-content');
                const privacySelect = node.querySelector('#diary-private');
                const msg = node.querySelector('#dash-msg');
                const permalink = node.querySelector('#permalink');
                const tabEditor = node.querySelector('#tab-editor');
                const tabCalendar = node.querySelector('#tab-calendar');
                const secEditor = node.querySelector('#section-editor');
                const secCalendar = node.querySelector('#section-calendar');
                const btnEdit = node.querySelector('#btn-edit');
                const btnRefresh = node.querySelector('#btn-refresh');

                function setMsg(text, ok, quiet) { try { if (!quiet) toast(text, ok); } catch (e) {} msg.textContent = ''; msg.style.display = 'none'; }
                function clearMsg() { msg.textContent = ''; msg.style.display = 'none'; }

                function setPermalink() {
                    const d = dateInput.value || today();
                    const base = window.location.origin + basePath();
                    const display = toDisplayDate(d);
                    permalink.href = base + '/' + encodeURIComponent(user.username) + '/' + display + '#public';
                    permalink.textContent = permalink.href;
                }
                setPermalink();

                // Tabs
                function showEditor() { secEditor.style.display = ''; secCalendar.style.display = 'none'; tabEditor.classList.remove('ghost'); tabCalendar.classList.add('ghost'); }
                function showCalendar() { secEditor.style.display = 'none'; secCalendar.style.display = ''; tabEditor.classList.add('ghost'); tabCalendar.classList.remove('ghost'); }
                tabEditor.addEventListener('click', showEditor);
                tabCalendar.addEventListener('click', showCalendar);

                // Edit mode toggle (read-only by default)
                let editMode = false;
                let currentHasEntry = false;
                let lastSavedSnapshot = { title: '', content: '', privacy: 'public', date: dateInput.value };
                let autosaveTimer = null;
                let autosaveInFlight = false;
                let lastAutosaveTime = null;
                let statusUpdateTimer = null;
                function applyEditMode() {
                    const disabled = !editMode;
                    titleInput.disabled = disabled;
                    contentInput.disabled = disabled;
                    privacySelect.disabled = disabled;
                    dateInput.disabled = false; // allow switching date even in view mode
                    q('#btn-save', node).style.display = editMode ? '' : 'none';
                    q('#btn-update', node).style.display = editMode ? '' : 'none';
                    q('#btn-delete', node).style.display = editMode ? '' : 'none';
                    btnEdit.textContent = editMode ? 'Done' : 'Edit';
                    
                    // Show/hide autosave indicator
                    const autosaveIndicator = q('#autosave-indicator', node);
                    if (editMode) {
                        autosaveIndicator.style.display = 'block';
                        if (!autosaveTimer) autosaveTimer = setInterval(tryAutoSave, 5000);
                        if (!statusUpdateTimer) statusUpdateTimer = setInterval(updateAutosaveStatus, 1000);
                    } else {
                        autosaveIndicator.style.display = 'none';
                        if (autosaveTimer) { clearInterval(autosaveTimer); autosaveTimer = null; }
                        if (statusUpdateTimer) { clearInterval(statusUpdateTimer); statusUpdateTimer = null; }
                    }
                }
                btnEdit.addEventListener('click', async () => {
                    const wasEditing = editMode;
                    editMode = !editMode;
                    if (wasEditing && !editMode) {
                        await tryAutoSave(true);
                    }
                    applyEditMode();
                });
                applyEditMode();

                function isDirty() {
                    return (
                        lastSavedSnapshot.title !== titleInput.value ||
                        lastSavedSnapshot.content !== contentInput.value ||
                        String(lastSavedSnapshot.privacy) !== String(privacySelect.value) ||
                        lastSavedSnapshot.date !== (dateInput.value || today())
                    );
                }

                function updateAutosaveStatus() {
                    const statusEl = q('#autosave-status', node);
                    if (lastAutosaveTime) {
                        const timeAgo = Math.floor((Date.now() - lastAutosaveTime) / 1000);
                        if (timeAgo < 60) {
                            statusEl.textContent = `Auto-saved ${timeAgo}s ago`;
                        } else {
                            statusEl.textContent = `Auto-saved ${Math.floor(timeAgo / 60)}m ago`;
                        }
                    } else {
                        statusEl.textContent = 'Auto-save active';
                    }
                }

                async function tryAutoSave(force) {
                    if (autosaveInFlight) return;
                    if (!force && !editMode) return;
                    if (!force && !isDirty()) return;
                    const hasContent = (contentInput.value || '').trim().length > 0;
                    const hasTitle = (titleInput.value || '').trim().length > 0;
                    const creatingNewEmpty = !currentHasEntry && !hasTitle && !hasContent;
                    if (!force && creatingNewEmpty) return;
                    if (creatingNewEmpty && force) {
                        // Leaving edit mode with nothing typed and no existing entry: do nothing
                        return;
                    }
                    autosaveInFlight = true;
                    try {
                        if (currentHasEntry) {
                            await update();
                            if (force) setMsg('Auto-saved at ' + new Date().toLocaleTimeString(), true);
                        } else {
                            await save();
                            currentHasEntry = true;
                            if (force) setMsg('Auto-saved at ' + new Date().toLocaleTimeString(), true);
                        }
                        lastSavedSnapshot = { title: titleInput.value, content: contentInput.value, privacy: privacySelect.value, date: dateInput.value || today() };
                        lastAutosaveTime = Date.now();
                        updateAutosaveStatus();
                    } catch (e) {
                        if (force) setMsg('Auto-save failed: ' + e.message, false);
                    } finally {
                        autosaveInFlight = false;
                    }
                }

                // Calendar
                let calYear = new Date().getFullYear();
                let calMonth = new Date().getMonth(); // 0-11
                const calLabel = node.querySelector('#cal-label');
                const calPrev = node.querySelector('#cal-prev');
                const calNext = node.querySelector('#cal-next');
                const calHost = node.querySelector('#calendar');

                calPrev.addEventListener('click', () => { calMonth--; if (calMonth < 0) { calMonth = 11; calYear--; } renderCalendar(); });
                calNext.addEventListener('click', () => { calMonth++; if (calMonth > 11) { calMonth = 0; calYear++; } renderCalendar(); });

                async function renderCalendar() {
                    const first = new Date(calYear, calMonth, 1);
                    const monthStr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0');
                    calLabel.textContent = first.toLocaleString(undefined, { month: 'long', year: 'numeric' });
                    calHost.innerHTML = '';
                    const grid = document.createElement('div');
                    grid.style.display = 'grid';
                    grid.style.gridTemplateColumns = 'repeat(7,1fr)';
                    grid.style.gap = '8px';
                    const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    weekdays.forEach(d => { const h = document.createElement('div'); h.className = 'helper'; h.textContent = d; grid.appendChild(h); });
                    const startPad = first.getDay();
                    const daysInMonth = new Date(calYear, calMonth + 1, 0).getDate();
                    for (let i = 0; i < startPad; i++) { const pad = document.createElement('div'); grid.appendChild(pad); }
                    let entriesByDate = {};
                    // Prefer client cache if available
                    if (clientCache.userLoadedAll && clientCache.userEntries) {
                        for (const e of clientCache.userEntries) {
                            if (!e.date.startsWith(monthStr)) continue;
                            const list = entriesByDate[e.date] || (entriesByDate[e.date] = []);
                            list.push(e);
                        }
                    } else {
                        // fallback quick fetch for current month
                        try {
                            const res = await apiGet({ action: 'getUserDiaryEntries', userId: user.id, month: monthStr });
                            if (res.success && Array.isArray(res.entries)) {
                                for (const e of res.entries) {
                                    const list = entriesByDate[e.date] || (entriesByDate[e.date] = []);
                                    list.push(e);
                                }
                            }
                        } catch (err) { }
                    }
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dstr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                        const cell = document.createElement('div');
                        cell.style.border = '1px solid var(--border)';
                        cell.style.borderRadius = '10px';
                        cell.style.padding = '8px';
                        cell.style.minHeight = '72px';
                        cell.style.height = '96px';
                        cell.style.overflow = 'hidden';
                        cell.style.display = 'flex';
                        cell.style.flexDirection = 'column';
                        cell.style.background = 'var(--input)';
                        const head = document.createElement('div'); head.className = 'helper'; head.textContent = day; cell.appendChild(head);
                        const list = entriesByDate[dstr] || [];
                        const count = list.length;
                        if (count > 0) {
                            const a = document.createElement('a'); a.className = 'link truncate'; a.href = `${basePath()}/${encodeURIComponent(user.username)}/${toDisplayDate(dstr)}`; a.target = '_blank'; a.rel = 'noopener';
                            const first = list[0];
                            const pval = first.privacy || (first.isPrivate === true || first.isPrivate === 'true' ? 'private' : 'public');
                            const label = pval === 'friend' ? ' (friend)' : (pval === 'private' ? ' (private)' : '');
                            a.textContent = (first.title || 'Untitled') + label;
                            a.title = (first.title || 'Untitled') + label;
                            try { cell.title = list.map(e => { const pv = e.privacy || (e.isPrivate === true || e.isPrivate === 'true' ? 'private' : 'public'); const lb = pv === 'friend' ? ' (friend)' : (pv === 'private' ? ' (private)' : ''); return (e.title || 'Untitled') + lb; }).join('\n'); } catch (e) {}
                            const p = document.createElement('div'); p.style.marginTop = '6px'; p.appendChild(a); cell.appendChild(p);
                            const badge = document.createElement('span'); badge.className = 'badge'; badge.textContent = String(count);
                            badge.style.float = 'right';
                            head.appendChild(badge);
                        } else {
                            const p = document.createElement('div'); p.className = 'helper'; p.style.marginTop = '6px'; p.textContent = '—'; cell.appendChild(p);
                        }
                        cell.addEventListener('click', () => { dateInput.value = dstr; showEditor(); setPermalink(); });
                        grid.appendChild(cell);
                    }
                    calHost.appendChild(grid);
                    // Hide overlay after first calendar paint
                    hideOverlay();
                }

                // default to Editor; user can open Calendar tab
                renderCalendar();

                async function loadRecent() {
                    try {
                        // Prefer cache if loaded
                        if (clientCache.userLoadedAll && Array.isArray(clientCache.userEntries)) {
                            const wrap = node.querySelector('#recent-list');
                            if (clientCache.userEntries.length === 0) { wrap.textContent = 'No entries yet.'; return; }
                            const list = document.createElement('div');
                            clientCache.userEntries.slice(0, 20).forEach(e => {
                                const item = document.createElement('div');
                                item.style.marginBottom = '10px';

                                const a = document.createElement('a');
                                a.className = 'link';
                                a.href = `${basePath()}/${encodeURIComponent(user.username)}/${toDisplayDate(e.date)}`;
                                const pval = e.privacy || (e.isPrivate === true || e.isPrivate === 'true' ? 'private' : 'public');
                                const label = pval === 'friend' ? '(friend)' : (pval === 'private' ? '(private)' : '');
                                a.textContent = `${toDisplayDate(e.date)} — ${e.title || 'Untitled'} ${label}`;
                                a.target = '_blank'; a.rel = 'noopener';

                                const preview = document.createElement('div');
                                preview.className = 'helper';
                                const text = String(e.content || '').replace(/\s+/g, ' ').trim();
                                const snippet = text.length > 160 ? text.slice(0, 160) + '…' : text;
                                preview.textContent = snippet || '—';

                                item.appendChild(a);
                                item.appendChild(preview);
                                list.appendChild(item);
                            });
                            wrap.innerHTML = ''; wrap.appendChild(list);
                            return;
                        }

                        const res = await apiGet({ action: 'getUserDiaryEntries', userId: user.id });
                        const wrap = node.querySelector('#recent-list');
                        if (!res.success) { wrap.textContent = res.error || 'Failed to load'; return; }
                        if (!res.entries || res.entries.length === 0) { wrap.textContent = 'No entries yet.'; return; }
                        const list = document.createElement('div');
                        res.entries.slice(0, 20).forEach(e => {
                            const item = document.createElement('div');
                            item.style.marginBottom = '10px';

                            const a = document.createElement('a');
                            a.className = 'link';
                            a.href = `${basePath()}/${encodeURIComponent(user.username)}/${toDisplayDate(e.date)}`;
                            const pval = e.privacy || (e.isPrivate === true || e.isPrivate === 'true' ? 'private' : 'public');
                            const label = pval === 'friend' ? '(friend)' : (pval === 'private' ? '(private)' : '');
                            a.textContent = `${toDisplayDate(e.date)} — ${e.title || 'Untitled'} ${label}`;
                            a.target = '_blank'; a.rel = 'noopener';

                            const preview = document.createElement('div');
                            preview.className = 'helper';
                            const text = String(e.content || '').replace(/\s+/g, ' ').trim();
                            const snippet = text.length > 160 ? text.slice(0, 160) + '…' : text;
                            preview.textContent = snippet || '—';

                            item.appendChild(a);
                            item.appendChild(preview);
                            list.appendChild(item);
                        });
                        wrap.innerHTML = ''; wrap.appendChild(list);
                    } catch (e) { const wrap = node.querySelector('#recent-list'); wrap.textContent = e.message; }
                }

                let currentLoadSeq = 0;
                async function load(force) {
                    clearMsg();
                    try {
                        const d = dateInput.value || today();
                        const seq = ++currentLoadSeq;
                        // Clear fields immediately on date switch to avoid showing stale content
                        titleInput.value = '';
                        contentInput.value = '';
                        privacySelect.value = 'public';
                        currentHasEntry = false;
                        if (!force && clientCache.userEmptyDates && clientCache.userEmptyDates.has(d)) {
                            titleInput.value = '';
                            contentInput.value = '';
                            privacySelect.value = 'public';
                            currentHasEntry = false;
                            lastSavedSnapshot = { title: '', content: '', privacy: 'public', date: d };
                            setMsg('No entry for ' + toDisplayDate(d), false, true);
                            return;
                        }
                        // Use private/self endpoint first
                        let ok = false;
                        currentHasEntry = false;
                        // If cache has the entry, use it
                        if (clientCache.userLoadedAll && clientCache.userEntriesByDate[d] && clientCache.userEntriesByDate[d].length > 0) {
                            const ownEntry = clientCache.userEntriesByDate[d][0];
                            titleInput.value = ownEntry.title || '';
                            contentInput.value = ownEntry.content || '';
                            privacySelect.value = ownEntry.privacy || (ownEntry.isPrivate === true || ownEntry.isPrivate === 'true' ? 'private' : 'public');
                            ok = true; currentHasEntry = true;
                        } else {
                            const own = await apiGet({ action: 'getUserDiaryEntry', userId: user.id, date: d });
                            if (own.success && own.entry) {
                                titleInput.value = own.entry.title || '';
                                contentInput.value = own.entry.content || '';
                                privacySelect.value = own.entry.privacy || (own.entry.isPrivate === true || own.entry.isPrivate === 'true' ? 'private' : 'public');
                                ok = true; currentHasEntry = true;
                            } else {
                                // Fallback to public view if this date is public and username/date requested directly
                                try {
                                    const pub = await apiGet({ action: 'getDiaryEntry', username: user.username, date: d, viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                                    if (pub.success && pub.entry) {
                                        titleInput.value = pub.entry.title || '';
                                        contentInput.value = pub.entry.content || '';
                                        ok = true;
                                    }
                                } catch (e) { }
                            }
                        }
                        if (seq !== currentLoadSeq) return; // ignore stale response
                        lastSavedSnapshot = { title: titleInput.value, content: contentInput.value, privacy: privacySelect.value, date: d };
                        if (ok) {
                            setMsg('Loaded entry for ' + toDisplayDate(d), true, true);
                            if (clientCache.userEmptyDates) clientCache.userEmptyDates.delete(d);
                        }
                        else {
                            titleInput.value = '';
                            contentInput.value = '';
                            privacySelect.value = 'public';
                            if (clientCache.userEmptyDates) clientCache.userEmptyDates.add(d);
                            setMsg('No entry for ' + toDisplayDate(d), false, true);
                        }
                    } catch (e) { setMsg(e.message, false); }
                }

                async function save() {
                    clearMsg();
                    const payload = {
                        action: 'saveDiaryEntry',
                        userId: user.id,
                        date: dateInput.value || today(),
                        title: titleInput.value,
                        content: contentInput.value,
                        privacy: privacySelect.value
                    };
                    try {
                        const res = await apiPost(payload);
                        if (res.success) {
                            setMsg('Saved.', true);
                            // update client cache
                            const entry = { date: payload.date, title: payload.title, content: payload.content, privacy: payload.privacy };
                            if (!Array.isArray(clientCache.userEntries)) clientCache.userEntries = [];
                            clientCache.userEntries.unshift(entry);
                            clientCache.userLoadedAll = true;
                            clientCache.userEntriesByDate[payload.date] = [entry];
                            if (clientCache.userEmptyDates) clientCache.userEmptyDates.delete(payload.date);
                            currentHasEntry = true;
                            // re-render dependents
                            renderCalendar();
                            loadRecent();
                        }
                        else { setMsg(res.error || res.message || 'Save failed', false); }
                    } catch (e) { setMsg(e.message, false); }
                }

                async function update() {
                    clearMsg();
                    const payload = {
                        action: 'updateDiaryEntry',
                        userId: user.id,
                        date: dateInput.value || today(),
                        title: titleInput.value,
                        content: contentInput.value,
                        privacy: privacySelect.value
                    };
                    try {
                        const res = await apiPost(payload);
                        if (res.success) {
                            setMsg('Updated.', true);
                            // update client cache
                            if (Array.isArray(clientCache.userEntries)) {
                                for (const e of clientCache.userEntries) { if (e.date === payload.date) { e.title = payload.title; e.content = payload.content; e.privacy = payload.privacy; break; } }
                            }
                            clientCache.userEntriesByDate[payload.date] = [{ date: payload.date, title: payload.title, content: payload.content, privacy: payload.privacy }];
                            if (clientCache.userEmptyDates) clientCache.userEmptyDates.delete(payload.date);
                            renderCalendar();
                            loadRecent();
                        }
                        else { setMsg(res.error || res.message || 'Update failed', false); }
                    } catch (e) { setMsg(e.message, false); }
                }

                async function remove() {
                    if (!confirm('Delete this entry?')) return;
                    clearMsg();
                    try {
                        const res = await apiPost({ action: 'deleteDiaryEntry', userId: user.id, date: dateInput.value || today() });
                        if (res.success) {
                            titleInput.value = ''; contentInput.value = '';
                            setMsg('Deleted.', true);
                            const d = dateInput.value || today();
                            if (Array.isArray(clientCache.userEntries)) { clientCache.userEntries = clientCache.userEntries.filter(e => e.date !== d); }
                            delete clientCache.userEntriesByDate[d];
                            if (clientCache.userEmptyDates) clientCache.userEmptyDates.add(d);
                            currentHasEntry = false;
                            renderCalendar();
                            loadRecent();
                        }
                        else { setMsg(res.error || 'Delete failed', false); }
                    } catch (e) { setMsg(e.message, false); }
                }

                node.querySelector('#btn-save').addEventListener('click', save);
                node.querySelector('#btn-update').addEventListener('click', update);
                node.querySelector('#btn-delete').addEventListener('click', remove);
                dateInput.addEventListener('change', () => { setPermalink(); load(false); });
                node.querySelector('#btn-prev-day').addEventListener('click', () => { dateInput.value = addDaysIso(dateInput.value || today(), -1); setPermalink(); load(false); });
                node.querySelector('#btn-next-day').addEventListener('click', () => { dateInput.value = addDaysIso(dateInput.value || today(), 1); setPermalink(); load(false); });
                btnRefresh.addEventListener('click', () => { load(true); });

                // Page unload protection - save before leaving
                window.addEventListener('beforeunload', (e) => {
                    if (editMode && isDirty()) {
                        e.preventDefault();
                        e.returnValue = 'You have unsaved changes. Are you sure you want to leave?';
                        // Try to save synchronously (this might not work in all browsers)
                        tryAutoSave(true);
                        return e.returnValue;
                    }
                });

                // Initial quick load of today's entry in view mode
                setMsg('Loading…', true, true);
                load(false).finally(() => { applyEditMode(); hideOverlay(); });

                // Prefetch all user entries once in background
                (async function prefetchAll() {
                    try {
                        const res = await apiGet({ action: 'getUserDiaryEntries', userId: user.id });
                        if (res.success && Array.isArray(res.entries)) {
                            clientCache.userEntries = res.entries;
                            clientCache.userEntriesByDate = {};
                            for (const e of res.entries) {
                                const list = clientCache.userEntriesByDate[e.date] || (clientCache.userEntriesByDate[e.date] = []);
                                list.push(e);
                            }
                            clientCache.userLoadedAll = true;
                            // refresh calendar and recent to avoid waiting later
                            renderCalendar();
                            loadRecent();
                            clearMsg();
                        } else { clearMsg(); }
                    } catch (e) { clearMsg(); }
                })();

                loadRecent();
                return node;
            }

            function PublicEntry(username, date) {
                const node = el(`
      <div class="card">
        <h3>Public diary</h3>
        <div class="helper">${username} · ${toDisplayDate(date)}</div>
        <div class="spacer"></div>
        <div style="display:flex;gap:8px;flex-wrap:wrap">
          <button id="pub-prev" class="ghost">Prev day</button>
          <button id="pub-next" class="ghost">Next day</button>
          <button id="pub-refresh" class="ghost">Refresh</button>
          <button id="pub-back" class="ghost">Back to calendar</button>
        </div>
        <div class="spacer"></div>
        <div id="pub-msg" class="notice" style="display:none"></div>
        <div id="pub-title" style="font-weight:600;font-size:16px;margin-bottom:6px"></div>
        <pre id="pub-content" style="white-space:pre-wrap;background:#0c121a;border:1px solid var(--border);padding:12px;border-radius:10px"></pre>
      </div>
    `);

                const msg = node.querySelector('#pub-msg');
                function setMsg(text, ok, quiet) { try { if (!quiet) toast(text, ok); } catch (e) {} msg.textContent = ''; msg.style.display = 'none'; }
                let currentLoadSeq = 0;

                async function renderFromCacheOrFetch(force) {
                    const cached = clientCache.publicByUser.get(username);
                    if (cached && cached.emptyDates instanceof Set && cached.emptyDates.has(date)) {
                        node.querySelector('#pub-title').textContent = '';
                        node.querySelector('#pub-content').textContent = '';
                        setMsg('Not found or private', false);
                        return true;
                    }
                    if (cached && cached.byDate && cached.byDate[date] && cached.byDate[date].length) {
                        const e = cached.byDate[date][0];
                        node.querySelector('#pub-title').textContent = e.title || '';
                        node.querySelector('#pub-content').textContent = e.content || '';
                        setMsg('Public entry', true);
                        return true;
                    }
                    return false;
                }

                async function loadPublic(force) {
                    const seq = ++currentLoadSeq;
                    setMsg('Loading…', true, true);
                    try {
                        const servedFromCache = await renderFromCacheOrFetch(force);
                        if (!servedFromCache) {
                            const res = await apiGet({ action: 'getDiaryEntry', username, date, viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                            if (seq !== currentLoadSeq) return; // ignore stale
                            if (res.success && res.entry) {
                                node.querySelector('#pub-title').textContent = res.entry.title || '';
                                node.querySelector('#pub-content').textContent = res.entry.content || '';
                                setMsg('Public entry', true, true);
                            } else {
                                const needLogin = /not authorized|private/i.test(String(res.error || ''));
                                const link = basePath() + '/';
                                const ask = needLogin ? ' Please login to see friend-only posts.' : '';
                                setMsg((res.error || 'Not found or private') + ask, false, true);
                                if (needLogin && !auth.user) {
                                    const hint = document.createElement('div');
                                    hint.className = 'helper';
                                    hint.style.marginTop = '8px';
                                    const a = document.createElement('a');
                                    a.href = link;
                                    a.className = 'link';
                                    a.textContent = 'Go to Home/Login';
                                    hint.appendChild(a);
                                    msg.appendChild(hint);
                                }
                                const existing = clientCache.publicByUser.get(username) || { entries: [], byDate: {}, emptyDates: new Set() };
                                if (!(existing.emptyDates instanceof Set)) existing.emptyDates = new Set();
                                existing.emptyDates.add(date);
                                clientCache.publicByUser.set(username, existing);
                            }
                        }
                        hideOverlay();
                        if (!clientCache.publicByUser.has(username)) clientCache.publicByUser.set(username, { entries: [], byDate: {}, emptyDates: new Set() });
                        (async function prefetchAllPublic() {
                            try {
                                const monthStr = date.slice(0, 7);
                                const month = await apiGet({ action: 'getPublicDiaryEntries', username, month: monthStr, maxContent: '220', viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                                const storeExisting = clientCache.publicByUser.get(username) || { entries: [], byDate: {}, emptyDates: new Set() };
                                if (!(storeExisting.emptyDates instanceof Set)) storeExisting.emptyDates = new Set();
                                if (month.success && Array.isArray(month.entries)) {
                                    for (const e of month.entries) { const list = storeExisting.byDate[e.date] || (storeExisting.byDate[e.date] = []); if (!list.find(x => x.date === e.date && x.title === e.title)) list.push(e); }
                                    storeExisting.entries = storeExisting.entries.concat(month.entries);
                                    clientCache.publicByUser.set(username, storeExisting);
                                }
                                const all = await apiGet({ action: 'getPublicDiaryEntries', username, limit: '500', viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                                if (all.success && Array.isArray(all.entries)) {
                                    const store = { entries: all.entries, byDate: {}, emptyDates: storeExisting.emptyDates };
                                    for (const e of all.entries) { const list = store.byDate[e.date] || (store.byDate[e.date] = []); list.push(e); }
                                    clientCache.publicByUser.set(username, store);
                                    await renderFromCacheOrFetch(false);
                                }
                            } catch (e) { }
                        })();
                    } catch (e) { setMsg(e.message, false); hideOverlay(); }
                }

                loadPublic(false);

                // Prev/Next day navigation
                node.querySelector('#pub-prev').addEventListener('click', () => {
                    const prev = addDaysIso(date, -1);
                    history.pushState({}, '', basePath() + '/' + encodeURIComponent(username) + '/' + toDisplayDate(prev));
                    render();
                });
                node.querySelector('#pub-next').addEventListener('click', () => {
                    const next = addDaysIso(date, 1);
                    history.pushState({}, '', basePath() + '/' + encodeURIComponent(username) + '/' + toDisplayDate(next));
                    render();
                });
                node.querySelector('#pub-refresh').addEventListener('click', () => { loadPublic(true); });
                node.querySelector('#pub-back').addEventListener('click', () => { history.pushState({}, '', basePath() + '/' + encodeURIComponent(username)); render(); });

                return node;
            }

            function PublicList() {
                const node = el(`
      <div class="card">
        <h3>Latest public entries</h3>
        <div id="pub-list" class="helper">Loading…</div>
      </div>
    `);

                (async function () {
                    try {
                        const res = await apiGet({ action: 'getPublicDiaryEntries', limit: '50', maxContent: '220', viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                        const wrap = node.querySelector('#pub-list');
                        if (!res.success) { wrap.textContent = res.error || 'Failed to load'; return; }
                        if (!res.entries || res.entries.length === 0) { wrap.textContent = 'No public entries yet.'; return; }
                        const list = document.createElement('div');
                        res.entries.slice(0, 50).forEach(e => {
                            const item = document.createElement('div');
                            item.style.marginBottom = '10px';
                            item.style.border = '1px solid var(--border)';
                            item.style.borderRadius = '10px';
                            item.style.padding = '10px';
                            item.style.background = 'var(--input)';

                            const a = document.createElement('a');
                            a.className = 'link';
                            a.href = `${basePath()}/${encodeURIComponent(e.username)}/${toDisplayDate(e.date)}`;
                            a.textContent = `${toDisplayDate(e.date)} – ${e.username}: ${e.title || 'Untitled'}`;
                            a.target = '_blank'; a.rel = 'noopener';

                            const preview = document.createElement('div');
                            preview.className = 'helper';
                            preview.style.marginTop = '6px';
                            const text = String(e.content || '').replace(/\s+/g, ' ').trim();
                            const snippet = text.length > 160 ? text.slice(0, 160) + '…' : text;
                            preview.textContent = snippet || '—';

                            item.appendChild(a);
                            item.appendChild(preview);
                            list.appendChild(item);
                        });
                        wrap.innerHTML = ''; wrap.appendChild(list);
                    } catch (e) { node.querySelector('#pub-list').textContent = e.message; }
                })();

                return node;
            }

            function PublicUser(username) {
                const node = el(`
      <div class="card">
        <h3>Public calendar</h3>
        <div class="helper">${username}</div>
        <div class="spacer"></div>
        <div style="display:flex;align-items:center;gap:8px;flex-wrap:wrap;margin-bottom:8px">
          <button id="cal-prev" class="ghost">Prev</button>
          <div id="cal-label" class="badge"></div>
          <button id="cal-next" class="ghost">Next</button>
        </div>
        <div id="calendar"></div>
        <div class="spacer"></div>
        <div id="month-strip"></div>
      </div>
    `);

                let calYear = new Date().getFullYear();
                let calMonth = new Date().getMonth();
                const calLabel = node.querySelector('#cal-label');
                const calPrev = node.querySelector('#cal-prev');
                const calNext = node.querySelector('#cal-next');
                const calHost = node.querySelector('#calendar');

                let publicEntries = null; // month-first, then all

                calPrev.addEventListener('click', () => { calMonth--; if (calMonth < 0) { calMonth = 11; calYear--; } renderCalendar(); });
                calNext.addEventListener('click', () => { calMonth++; if (calMonth > 11) { calMonth = 0; calYear++; } renderCalendar(); });

                async function ensureEntries() {
                    // If background all-data cache exists, use it
                    const cachedUser = clientCache.publicByUser.get(username);
                    if (cachedUser && Array.isArray(cachedUser.entries) && cachedUser.entries.length) {
                        publicEntries = cachedUser.entries;
                        return publicEntries;
                    }
                    if (publicEntries) return publicEntries;
                    // Quick month fetch for fast first paint
                    try {
                        const monthStr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0');
                        const res = await apiGet({ action: 'getPublicDiaryEntries', username, month: monthStr, maxContent: '160', viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                        publicEntries = (res.success && Array.isArray(res.entries)) ? res.entries : [];
                        try {
                            const existing = clientCache.publicByUser.get(username) || { entries: [], byDate: {}, emptyDates: new Set() };
                            for (const e of publicEntries) {
                                const list = existing.byDate[e.date] || (existing.byDate[e.date] = []);
                                if (!list.find(x => x.date === e.date && x.title === e.title)) list.push(e);
                            }
                            existing.entries = existing.entries.concat(publicEntries);
                            clientCache.publicByUser.set(username, existing);
                        } catch (e) {}
                    } catch (e) { publicEntries = []; }
                    // Background prefetch of all public entries for user
                    (async function prefetchAll() {
                        try {
                            const all = await apiGet({ action: 'getPublicDiaryEntries', username, limit: '500', maxContent: '220', viewerUserId: (auth.user && auth.user.id) ? auth.user.id : '' });
                            if (all.success && Array.isArray(all.entries)) {
                                const existingStore = clientCache.publicByUser.get(username) || { entries: [], byDate: {}, emptyDates: new Set() };
                                const store = { entries: all.entries, byDate: {}, emptyDates: (existingStore.emptyDates instanceof Set) ? existingStore.emptyDates : new Set() };
                                for (const e of all.entries) { const list = store.byDate[e.date] || (store.byDate[e.date] = []); list.push(e); }
                                clientCache.publicByUser.set(username, store);
                                publicEntries = all.entries;
                                // re-render current month with full data once ready
                                renderCalendar();
                            }
                        } catch (e) { }
                    })();
                    return publicEntries;
                }

                async function renderCalendar() {
                    const first = new Date(calYear, calMonth, 1);
                    const monthStr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0');
                    calLabel.textContent = first.toLocaleString(undefined, { month: 'long', year: 'numeric' });
                    calHost.innerHTML = '';
                    const loading = document.createElement('div'); loading.className = 'helper'; loading.textContent = 'Loading…'; calHost.appendChild(loading);
                    // Hide overlay early so the calendar shell is visible immediately
                    hideOverlay();
                    const grid = document.createElement('div');
                    grid.style.display = 'grid';
                    grid.style.gridTemplateColumns = 'repeat(7,1fr)';
                    grid.style.gap = '8px';
                    const weekdays = ['Sun', 'Mon', 'Tue', 'Wed', 'Thu', 'Fri', 'Sat'];
                    weekdays.forEach(d => { const h = document.createElement('div'); h.className = 'helper'; h.textContent = d; grid.appendChild(h); });
                    const startPad = first.getDay();
                    const daysInMonth = new Date(calYear, calMonth + 1, 0).getDate();
                    for (let i = 0; i < startPad; i++) { const pad = document.createElement('div'); grid.appendChild(pad); }

                    const entries = await ensureEntries();
                    const entriesByDate = {};
                    for (const e of entries) {
                        const list = entriesByDate[e.date] || (entriesByDate[e.date] = []);
                        list.push(e);
                    }

                    calHost.innerHTML = '';
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dstr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                        const cell = document.createElement('div');
                        cell.style.border = '1px solid var(--border)';
                        cell.style.borderRadius = '10px';
                        cell.style.padding = '8px';
                        cell.style.minHeight = '72px';
                        cell.style.height = '96px';
                        cell.style.overflow = 'hidden';
                        cell.style.display = 'flex';
                        cell.style.flexDirection = 'column';
                        cell.style.background = 'var(--input)';
                        const head = document.createElement('div'); head.className = 'helper'; head.textContent = day; cell.appendChild(head);
                        const list = entriesByDate[dstr] || [];
                        const count = list.length;
                        if (count > 0) {
                            const a = document.createElement('a'); a.className = 'link truncate'; a.href = `${basePath()}/${encodeURIComponent(username)}/${toDisplayDate(dstr)}`; a.target = '_blank'; a.rel = 'noopener';
                            const first = list[0];
                            a.textContent = (first.title || 'Untitled');
                            a.title = (first.title || 'Untitled');
                            try { cell.title = list.map(e => (e.title || 'Untitled')).join('\n'); } catch (e) {}
                            const p = document.createElement('div'); p.style.marginTop = '6px'; p.appendChild(a); cell.appendChild(p);
                            const badge = document.createElement('span'); badge.className = 'badge'; badge.textContent = String(count);
                            badge.style.float = 'right';
                            head.appendChild(badge);
                        } else {
                            const p = document.createElement('div'); p.className = 'helper'; p.style.marginTop = '6px'; p.textContent = '—'; cell.appendChild(p);
                        }
                        cell.addEventListener('click', () => { history.pushState({}, '', `${basePath()}/${encodeURIComponent(username)}/${toDisplayDate(dstr)}`); render(); });
                        grid.appendChild(cell);
                    }
                    calHost.appendChild(grid);

                    // Month strip (narrow bar showing daily availability)
                    const strip = node.querySelector('#month-strip');
                    strip.innerHTML = '';
                    const stripGrid = document.createElement('div');
                    stripGrid.style.display = 'grid';
                    stripGrid.style.gridTemplateColumns = `repeat(${daysInMonth},1fr)`;
                    stripGrid.style.gap = '2px';
                    stripGrid.style.alignItems = 'stretch';
                    for (let day = 1; day <= daysInMonth; day++) {
                        const dstr = String(calYear) + '-' + String(calMonth + 1).padStart(2, '0') + '-' + String(day).padStart(2, '0');
                        const bar = document.createElement('div');
                        const has = (entriesByDate[dstr] || []).length > 0;
                        bar.style.height = '6px';
                        bar.style.borderRadius = '4px';
                        bar.style.background = has ? 'var(--accent)' : 'var(--border)';
                        bar.title = toDisplayDate(dstr);
                        bar.style.cursor = 'pointer';
                        bar.addEventListener('click', () => { history.pushState({}, '', `${basePath()}/${encodeURIComponent(username)}/${toDisplayDate(dstr)}`); render(); });
                        stripGrid.appendChild(bar);
                    }
                    strip.appendChild(stripGrid);

                    // Hide overlay after first calendar paint for public user calendar
                    hideOverlay();
                }

                renderCalendar();
                return node;
            }

            q('#nav-logout').addEventListener('click', (e) => { e.preventDefault(); auth.user = null; render(); });
            window.addEventListener('hashchange', render);
            window.addEventListener('popstate', render);

            // Initial render
            render();
        })();
    </script>
</body>

</html>